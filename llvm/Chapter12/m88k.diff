commit 92af470694a18616a8326d7d2d9679479881fd96
Author: Kai Nacke <kai@redstar.de>
Date:   Sun Apr 4 10:34:53 2021 -0400

    Add m88k target.

diff --git a/llvm/CMakeLists.txt b/llvm/CMakeLists.txt
index 277d0fe54d7b..59e4180fca4f 100644
--- a/llvm/CMakeLists.txt
+++ b/llvm/CMakeLists.txt
@@ -314,7 +314,7 @@ set(LLVM_TARGETS_WITH_JIT X86 PowerPC AArch64 ARM Mips SystemZ)
 set(LLVM_TARGETS_TO_BUILD "all"
     CACHE STRING "Semicolon-separated list of targets to build, or \"all\".")
 
-set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ""
+set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD "M88k"
   CACHE STRING "Semicolon-separated list of experimental targets to build.")
 
 option(BUILD_SHARED_LIBS
diff --git a/llvm/include/llvm/ADT/Triple.h b/llvm/include/llvm/ADT/Triple.h
index eed315c929ad..7d19afb81742 100644
--- a/llvm/include/llvm/ADT/Triple.h
+++ b/llvm/include/llvm/ADT/Triple.h
@@ -58,6 +58,8 @@ public:
     bpfeb,          // eBPF or extended BPF or 64-bit BPF (big endian)
     csky,           // CSKY: csky
     hexagon,        // Hexagon: hexagon
+    m88k,           // M88000 (big endian): m88k
+    m88kel,         // M88000: (little endian) m88kel
     mips,           // MIPS: mips, mipsallegrex, mipsr6
     mipsel,         // MIPSEL: mipsel, mipsallegrexe, mipsr6el
     mips64,         // MIPS64: mips64, mips64r6, mipsn32, mipsn32r6
@@ -735,6 +737,11 @@ public:
                : PointerWidth == 64;
   }
 
+  /// Tests whether the target is M88k.
+  bool isM88k() const {
+    return getArch() == Triple::m88k;
+  }
+
   /// Tests whether the target is MIPS 32-bit (little and big endian).
   bool isMIPS32() const {
     return getArch() == Triple::mips || getArch() == Triple::mipsel;
diff --git a/llvm/include/llvm/BinaryFormat/ELF.h b/llvm/include/llvm/BinaryFormat/ELF.h
index 1552303b610c..153fe85b4916 100644
--- a/llvm/include/llvm/BinaryFormat/ELF.h
+++ b/llvm/include/llvm/BinaryFormat/ELF.h
@@ -492,6 +492,17 @@ enum {
 #include "ELFRelocs/AVR.def"
 };
 
+// M88k Specific e_flags
+enum : unsigned {
+  EF_88K_NABI = 0x80000000,   // Not ABI compliant
+  EF_88K_M88110 = 0x00000004  // File uses 88110-specific features
+};
+
+// M88k relocations.
+enum {
+#include "ELFRelocs/M88k.def"
+};
+
 // Mips Specific e_flags
 enum : unsigned {
   EF_MIPS_NOREORDER = 0x00000001, // Don't reorder instructions
diff --git a/llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def b/llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def
new file mode 100644
index 000000000000..50f2fa367225
--- /dev/null
+++ b/llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def
@@ -0,0 +1,75 @@
+
+#ifndef ELF_RELOC
+#error "ELF_RELOC must be defined"
+#endif
+
+// Based on:
+// SYSTEM V APPLICATION BINARY INTERFACE, Motorola 88000 Processor Supplement
+// See: https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463
+
+ELF_RELOC(R_88K_NONE, 0)
+ELF_RELOC(R_88K_COPY, 1)
+ELF_RELOC(R_88K_GOTP_ENT, 2)
+ELF_RELOC(R_88K_8, 4)
+ELF_RELOC(R_88K_8S, 5)
+ELF_RELOC(R_88K_16S, 7)
+ELF_RELOC(R_88K_DISP16, 8)
+ELF_RELOC(R_88K_DISP26, 10)
+ELF_RELOC(R_88K_PLT_DISP26, 14)
+ELF_RELOC(R_88K_BBASED_32, 16)
+ELF_RELOC(R_88K_BBASED_32UA, 17)
+ELF_RELOC(R_88K_BBASED_16H, 18)
+ELF_RELOC(R_88K_BBASED_16L, 19)
+ELF_RELOC(R_88K_ABDIFF_32, 24)
+ELF_RELOC(R_88K_ABDIFF_32UA, 25)
+ELF_RELOC(R_88K_ABDIFF_16H, 26)
+ELF_RELOC(R_88K_ABDIFF_16L, 27)
+ELF_RELOC(R_88K_ABDIFF_16, 28)
+ELF_RELOC(R_88K_32, 32)
+ELF_RELOC(R_88K_32UA, 33)
+ELF_RELOC(R_88K_16H, 34)
+ELF_RELOC(R_88K_16L, 35)
+ELF_RELOC(R_88K_16, 36)
+ELF_RELOC(R_88K_GOT_32, 40)
+ELF_RELOC(R_88K_GOT_32UA, 41)
+ELF_RELOC(R_88K_GOT_16H, 42)
+ELF_RELOC(R_88K_GOT_16L, 43)
+ELF_RELOC(R_88K_GOT_16, 44)
+ELF_RELOC(R_88K_GOTP_32, 48)
+ELF_RELOC(R_88K_GOTP_32UA, 49)
+ELF_RELOC(R_88K_GOTP_16H, 50)
+ELF_RELOC(R_88K_GOTP_16L, 51)
+ELF_RELOC(R_88K_GOTP_16, 52)
+ELF_RELOC(R_88K_PLT_32, 56)
+ELF_RELOC(R_88K_PLT_32UA, 57)
+ELF_RELOC(R_88K_PLT_16H, 58)
+ELF_RELOC(R_88K_PLT_16L, 59)
+ELF_RELOC(R_88K_PLT_16, 60)
+ELF_RELOC(R_88K_ABREL_32, 64)
+ELF_RELOC(R_88K_ABREL_32UA, 65)
+ELF_RELOC(R_88K_ABREL_16H, 66)
+ELF_RELOC(R_88K_ABREL_16L, 67)
+ELF_RELOC(R_88K_ABREL_16, 68)
+ELF_RELOC(R_88K_GOT_ABREL_32, 72)
+ELF_RELOC(R_88K_GOT_ABREL_32UA, 73)
+ELF_RELOC(R_88K_GOT_ABREL_16H, 74)
+ELF_RELOC(R_88K_GOT_ABREL_16L, 75)
+ELF_RELOC(R_88K_GOT_ABREL_16, 76)
+ELF_RELOC(R_88K_GOTP_ABREL_32, 80)
+ELF_RELOC(R_88K_GOTP_ABREL_32UA, 81)
+ELF_RELOC(R_88K_GOTP_ABREL_16H, 82)
+ELF_RELOC(R_88K_GOTP_ABREL_16L, 83)
+ELF_RELOC(R_88K_GOTP_ABREL_16, 84)
+ELF_RELOC(R_88K_PLT_ABREL_32, 88)
+ELF_RELOC(R_88K_PLT_ABREL_32UA, 89)
+ELF_RELOC(R_88K_PLT_ABREL_16H, 90)
+ELF_RELOC(R_88K_PLT_ABREL_16L, 91)
+ELF_RELOC(R_88K_PLT_ABREL_16, 92)
+ELF_RELOC(R_88K_SREL_32, 96)
+ELF_RELOC(R_88K_SREL_32UA, 97)
+ELF_RELOC(R_88K_SREL_16H, 98)
+ELF_RELOC(R_88K_SREL_16L, 99)
+
+/* These are GNU extensions to enable C++ vtable garbage collection. */
+ELF_RELOC(R_88K_GNU_VTINHERIT, 100)
+ELF_RELOC(R_88K_GNU_VTENTRY, 101)
diff --git a/llvm/include/llvm/Object/ELFObjectFile.h b/llvm/include/llvm/Object/ELFObjectFile.h
index fed53eef68c3..9a50aa2f6475 100644
--- a/llvm/include/llvm/Object/ELFObjectFile.h
+++ b/llvm/include/llvm/Object/ELFObjectFile.h
@@ -1155,6 +1155,8 @@ StringRef ELFObjectFile<ELFT>::getFileFormatName() const {
       return "elf32-hexagon";
     case ELF::EM_LANAI:
       return "elf32-lanai";
+    case ELF::EM_88K:
+      return "elf32-m88k";
     case ELF::EM_MIPS:
       return "elf32-mips";
     case ELF::EM_MSP430:
@@ -1224,6 +1226,8 @@ template <class ELFT> Triple::ArchType ELFObjectFile<ELFT>::getArch() const {
     return Triple::hexagon;
   case ELF::EM_LANAI:
     return Triple::lanai;
+  case ELF::EM_88K:
+    return IsLittleEndian ? Triple::m88kel : Triple::m88k;
   case ELF::EM_MIPS:
     switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {
     case ELF::ELFCLASS32:
diff --git a/llvm/lib/Object/ELF.cpp b/llvm/lib/Object/ELF.cpp
index 264f115ddbb5..c7d2141b0597 100644
--- a/llvm/lib/Object/ELF.cpp
+++ b/llvm/lib/Object/ELF.cpp
@@ -37,6 +37,13 @@ StringRef llvm::object::getELFRelocationTypeName(uint32_t Machine,
       break;
     }
     break;
+  case ELF::EM_88K:
+    switch (Type) {
+#include "llvm/BinaryFormat/ELFRelocs/M88k.def"
+    default:
+      break;
+    }
+    break;
   case ELF::EM_MIPS:
     switch (Type) {
 #include "llvm/BinaryFormat/ELFRelocs/Mips.def"
diff --git a/llvm/lib/ObjectYAML/ELFYAML.cpp b/llvm/lib/ObjectYAML/ELFYAML.cpp
index 05d30577812b..39f28c385f55 100644
--- a/llvm/lib/ObjectYAML/ELFYAML.cpp
+++ b/llvm/lib/ObjectYAML/ELFYAML.cpp
@@ -691,6 +691,9 @@ void ScalarEnumerationTraits<ELFYAML::ELF_REL>::enumeration(
   case ELF::EM_PPC64:
 #include "llvm/BinaryFormat/ELFRelocs/PowerPC64.def"
     break;
+  case ELF::EM_88K:
+#include "llvm/BinaryFormat/ELFRelocs/M88k.def"
+    break;
   default:
     // Nothing to do.
     break;
diff --git a/llvm/lib/Support/Triple.cpp b/llvm/lib/Support/Triple.cpp
index 4f483c965282..016a7800c7c0 100644
--- a/llvm/lib/Support/Triple.cpp
+++ b/llvm/lib/Support/Triple.cpp
@@ -44,6 +44,8 @@ StringRef Triple::getArchTypeName(ArchType Kind) {
   case lanai:          return "lanai";
   case le32:           return "le32";
   case le64:           return "le64";
+  case m88k:           return "m88k";
+  case m88kel:         return "m88kel";
   case mips64:         return "mips64";
   case mips64el:       return "mips64el";
   case mips:           return "mips";
@@ -105,6 +107,9 @@ StringRef Triple::getArchTypePrefix(ArchType Kind) {
   case ppc:
   case ppcle:       return "ppc";
 
+  case m88k:
+  case m88kel:      return "m88k";
+
   case mips:
   case mipsel:
   case mips64:
@@ -281,6 +286,8 @@ Triple::ArchType Triple::getArchTypeForLLVMName(StringRef Name) {
     .Case("armeb", armeb)
     .Case("avr", avr)
     .StartsWith("bpf", BPFArch)
+    .Case("m88k", m88k)
+    .Case("m88kel", m88kel)
     .Case("mips", mips)
     .Case("mipsel", mipsel)
     .Case("mips64", mips64)
@@ -419,6 +426,8 @@ static Triple::ArchType parseArch(StringRef ArchName) {
     .Case("thumb", Triple::thumb)
     .Case("thumbeb", Triple::thumbeb)
     .Case("avr", Triple::avr)
+    .Case("m88k", Triple::m88k)
+    .Case("m88kel", Triple::m88kel)
     .Case("msp430", Triple::msp430)
     .Cases("mips", "mipseb", "mipsallegrex", "mipsisa32r6",
            "mipsr6", Triple::mips)
@@ -703,6 +712,8 @@ static Triple::ObjectFormatType getDefaultFormat(const Triple &T) {
   case Triple::lanai:
   case Triple::le32:
   case Triple::le64:
+  case Triple::m88k:
+  case Triple::m88kel:
   case Triple::mips64:
   case Triple::mips64el:
   case Triple::mips:
@@ -1276,6 +1287,8 @@ static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
   case llvm::Triple::kalimba:
   case llvm::Triple::lanai:
   case llvm::Triple::le32:
+  case llvm::Triple::m88k:
+  case llvm::Triple::m88kel:
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::nvptx:
@@ -1360,6 +1373,8 @@ Triple Triple::get32BitArchVariant() const {
   case Triple::kalimba:
   case Triple::lanai:
   case Triple::le32:
+  case Triple::m88k:
+  case Triple::m88kel:
   case Triple::mips:
   case Triple::mipsel:
   case Triple::nvptx:
@@ -1412,6 +1427,8 @@ Triple Triple::get64BitArchVariant() const {
   case Triple::hexagon:
   case Triple::kalimba:
   case Triple::lanai:
+  case Triple::m88k:
+  case Triple::m88kel:
   case Triple::msp430:
   case Triple::r600:
   case Triple::shave:
@@ -1515,6 +1532,7 @@ Triple Triple::getBigEndianArchVariant() const {
   case Triple::aarch64: T.setArch(Triple::aarch64_be); break;
   case Triple::bpfel:   T.setArch(Triple::bpfeb);      break;
   case Triple::mips64el:T.setArch(Triple::mips64);     break;
+  case Triple::m88kel:  T.setArch(Triple::m88k);       break;
   case Triple::mipsel:  T.setArch(Triple::mips);       break;
   case Triple::ppcle:   T.setArch(Triple::ppc);        break;
   case Triple::ppc64le: T.setArch(Triple::ppc64);      break;
@@ -1546,6 +1564,7 @@ Triple Triple::getLittleEndianArchVariant() const {
 
   case Triple::aarch64_be: T.setArch(Triple::aarch64);  break;
   case Triple::bpfeb:      T.setArch(Triple::bpfel);    break;
+  case Triple::m88k:       T.setArch(Triple::m88kel);   break;
   case Triple::mips64:     T.setArch(Triple::mips64el); break;
   case Triple::mips:       T.setArch(Triple::mipsel);   break;
   case Triple::ppc:        T.setArch(Triple::ppcle);    break;
@@ -1575,6 +1594,7 @@ bool Triple::isLittleEndian() const {
   case Triple::kalimba:
   case Triple::le32:
   case Triple::le64:
+  case Triple::m88kel:
   case Triple::mips64el:
   case Triple::mipsel:
   case Triple::msp430:
diff --git a/llvm/lib/Target/M88k/AsmParser/CMakeLists.txt b/llvm/lib/Target/M88k/AsmParser/CMakeLists.txt
new file mode 100644
index 000000000000..0fb91ef5dd23
--- /dev/null
+++ b/llvm/lib/Target/M88k/AsmParser/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_llvm_component_library(LLVMM88kAsmParser
+  M88kAsmParser.cpp
+  )
diff --git a/llvm/lib/Target/M88k/AsmParser/LLVMBuild.txt b/llvm/lib/Target/M88k/AsmParser/LLVMBuild.txt
new file mode 100644
index 000000000000..5c20fe3547a7
--- /dev/null
+++ b/llvm/lib/Target/M88k/AsmParser/LLVMBuild.txt
@@ -0,0 +1,22 @@
+;===- ./lib/Target/M88k/AsmParser/LLVMBuild.txt -----------------*- Conf -*-===;
+;
+; Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+; See https://llvm.org/LICENSE.txt for license information.
+; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Library
+name = M88kAsmParser
+parent = M88k
+required_libraries = MC MCParser Support M88kDesc M88kInfo
+add_to_library_groups = M88k
diff --git a/llvm/lib/Target/M88k/AsmParser/M88kAsmParser.cpp b/llvm/lib/Target/M88k/AsmParser/M88kAsmParser.cpp
new file mode 100644
index 000000000000..848913370e05
--- /dev/null
+++ b/llvm/lib/Target/M88k/AsmParser/M88kAsmParser.cpp
@@ -0,0 +1,436 @@
+//===-- M88kAsmParser.cpp - Parse M88k assembly to MCInst instructions ----===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "MCTargetDesc/M88kInstPrinter.h"
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+#include "TargetInfo/M88kTargetInfo.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCParser/MCAsmLexer.h"
+#include "llvm/MC/MCParser/MCAsmParser.h"
+#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
+#include "llvm/MC/MCParser/MCTargetAsmParser.h"
+#include "llvm/MC/MCStreamer.h"
+#include "llvm/MC/MCSubtargetInfo.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/MathExtras.h"
+#include "llvm/Support/SMLoc.h"
+#include "llvm/Support/TargetRegistry.h"
+#include "llvm/Support/raw_ostream.h"
+#include <algorithm>
+#include <cassert>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+
+using namespace llvm;
+
+// Auto-generated by TableGen
+static unsigned MatchRegisterName(StringRef Name);
+
+namespace {
+
+// Return true if Expr is in the range [MinValue, MaxValue].
+bool inRange(const MCExpr *Expr, int64_t MinValue, int64_t MaxValue) {
+  if (auto *CE = dyn_cast<MCConstantExpr>(Expr)) {
+    int64_t Value = CE->getValue();
+    return Value >= MinValue && Value <= MaxValue;
+  }
+  return false;
+}
+
+// Instances of this class represented a parsed machine instruction
+class M88kOperand : public MCParsedAsmOperand {
+  enum OperandKind {
+    // KindInvalid,
+    OpKind_Token,
+    OpKind_Reg,
+    OpKind_Imm,
+    OpKind_Mem // Reg+Imm, Reg+Reg, Reg+(Reg<<(1,2,4,8))
+  };
+
+  OperandKind Kind;
+  SMLoc StartLoc, EndLoc;
+
+  // A string of length Length, starting at Data.
+  struct TokenOp {
+    const char *Data;
+    unsigned Length;
+  };
+
+  struct RegOp {
+    unsigned RegNo;
+  };
+
+  union {
+    TokenOp Token;
+    RegOp Reg;
+    const MCExpr *Imm;
+  };
+
+  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
+    // Add as immediates when possible.  Null MCExpr = 0.
+    if (!Expr)
+      Inst.addOperand(MCOperand::createImm(0));
+    else if (auto *CE = dyn_cast<MCConstantExpr>(Expr))
+      Inst.addOperand(MCOperand::createImm(CE->getValue()));
+    else
+      Inst.addOperand(MCOperand::createExpr(Expr));
+  }
+
+public:
+  M88kOperand(OperandKind kind, SMLoc startLoc, SMLoc endLoc)
+      : Kind(kind), StartLoc(startLoc), EndLoc(endLoc) {}
+
+  // getStartLoc - Gets location of the first token of this operand
+  SMLoc getStartLoc() const override { return StartLoc; }
+
+  // getEndLoc - Gets location of the last token of this operand
+  SMLoc getEndLoc() const override { return EndLoc; }
+
+  bool isReg() const override { return Kind == OpKind_Reg; }
+
+  unsigned getReg() const override {
+    assert(isReg() && "Invalid type access!");
+    return Reg.RegNo;
+  }
+
+  bool isImm() const override { return Kind == OpKind_Imm; }
+
+  bool isImm(int64_t MinValue, int64_t MaxValue) const {
+    return Kind == OpKind_Imm && inRange(Imm, MinValue, MaxValue);
+  }
+
+  const MCExpr *getImm() const {
+    assert(isImm() && "Invalid type access!");
+    return Imm;
+  }
+
+  bool isMem() const override { return Kind == OpKind_Mem; }
+
+  bool isToken() const override { return Kind == OpKind_Token; }
+
+  StringRef getToken() const {
+    assert(isToken() && "Not a token");
+    return StringRef(Token.Data, Token.Length);
+  }
+
+  static std::unique_ptr<M88kOperand> createToken(StringRef Str, SMLoc Loc) {
+    auto Op = std::make_unique<M88kOperand>(OpKind_Token, Loc, Loc);
+    Op->Token.Data = Str.data();
+    Op->Token.Length = Str.size();
+    return Op;
+  }
+
+  static std::unique_ptr<M88kOperand> createReg(unsigned Num, SMLoc StartLoc,
+                                                SMLoc EndLoc) {
+    auto Op = std::make_unique<M88kOperand>(OpKind_Reg, StartLoc, EndLoc);
+    Op->Reg.RegNo = Num;
+    return Op;
+  }
+
+  static std::unique_ptr<M88kOperand> createImm(const MCExpr *Expr,
+                                                SMLoc StartLoc, SMLoc EndLoc) {
+    auto Op = std::make_unique<M88kOperand>(OpKind_Imm, StartLoc, EndLoc);
+    Op->Imm = Expr;
+    return Op;
+  }
+
+  // Used by the TableGen code to add particular types of operand
+  // to an instruction.
+  void addRegOperands(MCInst &Inst, unsigned N) const {
+    assert(N == 1 && "Invalid number of operands");
+    Inst.addOperand(MCOperand::createReg(getReg()));
+  }
+
+  void addImmOperands(MCInst &Inst, unsigned N) const {
+    assert(N == 1 && "Invalid number of operands");
+    addExpr(Inst, getImm());
+  }
+
+  bool isU5Imm() const { return isImm(0, 31); }
+  // TODO
+  bool isU5ImmO() const { return isImm(0, 31); }
+  bool isU10ImmWO() const { return isImm(0, 1023); }
+  bool isU16Imm() const { return isImm(0, 65535); }
+  bool isS16Imm() const { return isImm(-32768, 32767); }
+
+  void print(raw_ostream &OS) const override {
+    switch (Kind) {
+    case OpKind_Imm:
+      OS << "Imm: " << getImm() << "\n";
+      break;
+    case OpKind_Token:
+      OS << "Token: " << getToken() << "\n";
+      break;
+    case OpKind_Reg:
+      OS << "Reg: %r" << /*getReg() <<*/ "\n";
+      break;
+    case OpKind_Mem:
+      OS << "MemImm: " << /* *getMemOffset() <<*/ "\n";
+      break;
+    }
+  }
+};
+
+class M88kAsmParser : public MCTargetAsmParser {
+// Auto-generated instruction matching functions
+#define GET_ASSEMBLER_HEADER
+#include "M88kGenAsmMatcher.inc"
+
+  bool ParseDirective(AsmToken DirectiveID) override;
+
+  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
+                        SMLoc NameLoc, OperandVector &Operands) override;
+
+  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;
+  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc,
+                     bool RestoreOnFailure);
+  OperandMatchResultTy tryParseRegister(unsigned &RegNo, SMLoc &StartLoc,
+                                        SMLoc &EndLoc) override;
+
+  bool parseOperand(OperandVector &Operands, StringRef Mnemonic);
+
+  OperandMatchResultTy parseImmWO(OperandVector &Operands);
+  OperandMatchResultTy parsePCRel16(OperandVector &Operands) {
+    // return parsePCRel(Operands, -(1LL << 16), (1LL << 16) - 1, false);
+    return MatchOperand_ParseFail;
+  }
+
+  OperandMatchResultTy parsePCRel26(OperandVector &Operands) {
+    return MatchOperand_ParseFail;
+  }
+
+  bool MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
+                               OperandVector &Operands, MCStreamer &Out,
+                               uint64_t &ErrorInfo,
+                               bool MatchingInlineAsm) override;
+
+public:
+  M88kAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
+                const MCInstrInfo &MII, const MCTargetOptions &Options)
+      : MCTargetAsmParser(Options, STI, MII), Parser(Parser),
+        Lexer(Parser.getLexer()), SubtargetInfo(STI) {
+    setAvailableFeatures(
+        ComputeAvailableFeatures(SubtargetInfo.getFeatureBits()));
+  }
+
+private:
+  MCAsmParser &Parser;
+  MCAsmLexer &Lexer;
+
+  const MCSubtargetInfo &SubtargetInfo;
+};
+
+} // end anonymous namespace
+
+#define GET_REGISTER_MATCHER
+#define GET_SUBTARGET_FEATURE_NAME
+#define GET_MATCHER_IMPLEMENTATION
+#define GET_MNEMONIC_SPELL_CHECKER
+#include "M88kGenAsmMatcher.inc"
+
+bool M88kAsmParser::ParseDirective(AsmToken DirectiveID) { return true; }
+
+bool M88kAsmParser::ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
+                                     SMLoc NameLoc, OperandVector &Operands) {
+  // First operand in MCInst is instruction mnemonic.
+  Operands.push_back(M88kOperand::createToken(Name, NameLoc));
+
+  // Read the remaining operands.
+  if (getLexer().isNot(AsmToken::EndOfStatement)) {
+    // Read the first operand.
+    if (parseOperand(Operands, Name)) {
+      return true;
+    }
+
+    // Read any subsequent operands.
+    while (getLexer().is(AsmToken::Comma)) {
+      Parser.Lex();
+      if (parseOperand(Operands, Name)) {
+        return true;
+      }
+    }
+    if (getLexer().isNot(AsmToken::EndOfStatement)) {
+      SMLoc Loc = getLexer().getLoc();
+      return Error(Loc, "unexpected token in argument list");
+    }
+  }
+
+  // Consume the EndOfStatement.
+  Parser.Lex();
+  return false;
+}
+
+bool M88kAsmParser::parseOperand(OperandVector &Operands, StringRef Mnemonic) {
+  // Invoke a custom associated parser.
+  OperandMatchResultTy Result = MatchOperandParserImpl(Operands, Mnemonic);
+
+  if (Result == MatchOperand_Success)
+    return Result;
+  if (Result == MatchOperand_ParseFail) {
+    Parser.eatToEndOfStatement();
+    return Result;
+  }
+  assert(Result == MatchOperand_NoMatch && "Unexpected match result");
+
+  // Check if it is a register.
+  if (Lexer.is(AsmToken::Percent)) {
+    unsigned RegNo;
+    SMLoc StartLoc, EndLoc;
+    if (ParseRegister(RegNo, StartLoc, EndLoc))
+      return true;
+    Operands.push_back(M88kOperand::createReg(RegNo, StartLoc, EndLoc));
+    return false;
+  }
+
+  // Could be immediate or address.
+  if (Lexer.is(AsmToken::Integer)) {
+    SMLoc StartLoc = Parser.getTok().getLoc();
+    const MCExpr *Expr;
+    if (Parser.parseExpression(Expr))
+      return true;
+    SMLoc EndLoc = Parser.getTok().getLoc();
+    Operands.push_back(M88kOperand::createImm(Expr, StartLoc, EndLoc));
+    return false;
+  }
+llvm::dbgs() << "parseOperand failed (" << Mnemonic << ")\n";
+  // Failure
+  return true;
+}
+
+OperandMatchResultTy M88kAsmParser::parseImmWO(OperandVector &Operands) {
+  // Parses operands like 5<6> and <7>.
+  MCContext &Ctx = getContext();
+  SMLoc StartLoc = Parser.getTok().getLoc();
+  Optional<AsmToken> WidthTok;
+  int64_t Width = 0, Offset;
+  if (Lexer.is(AsmToken::Integer)) {
+    WidthTok = Parser.getTok();
+    Width = Parser.getTok().getIntVal();
+    Parser.Lex();
+  }
+  if (Lexer.isNot(AsmToken::Less)) {
+    if (WidthTok)
+      Lexer.UnLex(WidthTok.getValue());
+    return MatchOperand_NoMatch;
+  }
+  Parser.Lex();
+  if (Lexer.isNot(AsmToken::Integer))
+    return MatchOperand_ParseFail;
+  Offset = Parser.getTok().getIntVal();
+  Parser.Lex();
+  if (Lexer.isNot(AsmToken::Greater))
+    return MatchOperand_ParseFail;
+  Parser.Lex();
+
+  // TODO Check values.
+  int64_t Val = Width << 5 | Offset;
+  const MCExpr *Expr = MCConstantExpr::create(Val, Ctx);
+  SMLoc EndLoc = Parser.getTok().getLoc();
+  Operands.push_back(M88kOperand::createImm(Expr, StartLoc, EndLoc));
+
+  // Announce no match.
+  return MatchOperand_Success;
+}
+
+// Parses register of form %r<No> or %x<No>.
+// TODO Do we need to handle fcrS/crS?
+bool M88kAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc,
+                                  SMLoc &EndLoc, bool RestoreOnFailure) {
+  StartLoc = Parser.getTok().getLoc();
+
+  // Eat the '%' prefix.
+  if (Parser.getTok().isNot(AsmToken::Percent))
+    return Error(Parser.getTok().getLoc(), "register expected");
+  const AsmToken &PercentTok = Parser.getTok();
+  Parser.Lex();
+
+  // Match the register
+  if (Lexer.getKind() != AsmToken::Identifier ||
+      (RegNo = MatchRegisterName(Lexer.getTok().getIdentifier())) == 0) {
+    if (RestoreOnFailure)
+      Lexer.UnLex(PercentTok);
+    return Error(StartLoc, "invalid register");
+  }
+
+  Parser.Lex(); // Eat identifier token
+  EndLoc = Parser.getTok().getLoc();
+  return false;
+}
+
+bool M88kAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc,
+                                  SMLoc &EndLoc) {
+  return ParseRegister(RegNo, StartLoc, EndLoc, /*RestoreOnFailure=*/false);
+}
+
+OperandMatchResultTy M88kAsmParser::tryParseRegister(unsigned &RegNo,
+                                                     SMLoc &StartLoc,
+                                                     SMLoc &EndLoc) {
+  bool Result =
+      ParseRegister(RegNo, StartLoc, EndLoc, /*RestoreOnFailure=*/true);
+  bool PendingErrors = getParser().hasPendingError();
+  getParser().clearPendingErrors();
+  if (PendingErrors)
+    return MatchOperand_ParseFail;
+  if (Result)
+    return MatchOperand_NoMatch;
+  return MatchOperand_Success;
+}
+
+bool M88kAsmParser::MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
+                                            OperandVector &Operands,
+                                            MCStreamer &Out,
+                                            uint64_t &ErrorInfo,
+                                            bool MatchingInlineAsm) {
+  MCInst Inst;
+  unsigned MatchResult;
+  FeatureBitset MissingFeatures;
+  MatchResult = MatchInstructionImpl(Operands, Inst, ErrorInfo, MissingFeatures,
+                                     MatchingInlineAsm);
+  switch (MatchResult) {
+  case Match_Success:
+    Inst.setLoc(IdLoc);
+    Out.emitInstruction(Inst, getSTI());
+    return false;
+  case Match_MissingFeature:
+    // Currently no features are implemented.
+    return Error(IdLoc, "Instruction use requires option to be enabled");
+  case Match_InvalidOperand: {
+    SMLoc ErrorLoc = IdLoc;
+    if (ErrorInfo != ~0U) {
+      if (ErrorInfo >= Operands.size())
+        return Error(IdLoc, "Too few operands for instruction");
+
+      // TODO
+      // ErrorLoc = ((M88kOperand &)*Operands[ErrorInfo]).getStartLoc();
+      if (ErrorLoc == SMLoc())
+        ErrorLoc = IdLoc;
+    }
+    return Error(ErrorLoc, "Invalid operand for instruction");
+  }
+  case Match_MnemonicFail: {
+    FeatureBitset FBS = ComputeAvailableFeatures(getSTI().getFeatureBits());
+    M88kOperand &Op = static_cast<M88kOperand &>(*Operands[0]);
+    std::string Suggestion = M88kMnemonicSpellCheck(Op.getToken(), FBS, 0);
+    return Error(IdLoc, "invalid instruction" + Suggestion/*,
+                 Op.getLocRange()*/);
+  }
+  }
+  llvm_unreachable("Unexpected match type");
+}
+
+extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kAsmParser() {
+  RegisterMCAsmParser<M88kAsmParser> x(getTheM88kTarget());
+}
diff --git a/llvm/lib/Target/M88k/CMakeLists.txt b/llvm/lib/Target/M88k/CMakeLists.txt
new file mode 100644
index 000000000000..68c2584a2f85
--- /dev/null
+++ b/llvm/lib/Target/M88k/CMakeLists.txt
@@ -0,0 +1,33 @@
+add_llvm_component_group(M88k)
+
+set(LLVM_TARGET_DEFINITIONS M88k.td)
+
+tablegen(LLVM M88kGenAsmMatcher.inc -gen-asm-matcher)
+tablegen(LLVM M88kGenAsmWriter.inc -gen-asm-writer)
+tablegen(LLVM M88kGenCallingConv.inc -gen-callingconv)
+tablegen(LLVM M88kGenDAGISel.inc -gen-dag-isel)
+tablegen(LLVM M88kGenDisassemblerTables.inc -gen-disassembler)
+tablegen(LLVM M88kGenInstrInfo.inc -gen-instr-info)
+tablegen(LLVM M88kGenMCCodeEmitter.inc -gen-emitter)
+tablegen(LLVM M88kGenRegisterInfo.inc -gen-register-info)
+tablegen(LLVM M88kGenSubtargetInfo.inc -gen-subtarget)
+
+add_public_tablegen_target(M88kCommonTableGen)
+
+add_llvm_target(M88kCodeGen
+  M88kAsmPrinter.cpp
+  M88kFrameLowering.cpp
+  M88kISelDAGToDAG.cpp
+  M88kISelLowering.cpp
+  M88kInstrInfo.cpp
+#  M88kMachineFunctionInfo.cpp
+  M88kMCInstLower.cpp
+  M88kRegisterInfo.cpp
+  M88kSubtarget.cpp
+  M88kTargetMachine.cpp
+  )
+
+add_subdirectory(AsmParser)
+add_subdirectory(Disassembler)
+add_subdirectory(TargetInfo)
+add_subdirectory(MCTargetDesc)
diff --git a/llvm/lib/Target/M88k/Disassembler/CMakeLists.txt b/llvm/lib/Target/M88k/Disassembler/CMakeLists.txt
new file mode 100644
index 000000000000..6f22cfbe8176
--- /dev/null
+++ b/llvm/lib/Target/M88k/Disassembler/CMakeLists.txt
@@ -0,0 +1,13 @@
+add_llvm_component_library(LLVMM88kDisassembler
+  M88kDisassembler.cpp
+
+  LINK_COMPONENTS
+  MC
+  MCDisassembler
+  Support
+  M88kDesc
+  M88kInfo
+
+  ADD_TO_COMPONENT
+  M88k
+  )
diff --git a/llvm/lib/Target/M88k/Disassembler/M88kDisassembler.cpp b/llvm/lib/Target/M88k/Disassembler/M88kDisassembler.cpp
new file mode 100644
index 000000000000..9395015c4235
--- /dev/null
+++ b/llvm/lib/Target/M88k/Disassembler/M88kDisassembler.cpp
@@ -0,0 +1,127 @@
+//===-- M88kDisassembler.cpp - Disassembler for M88k ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88k.h"
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+#include "TargetInfo/M88kTargetInfo.h"
+#include "llvm/MC/MCDisassembler/MCDisassembler.h"
+#include "llvm/MC/MCFixedLenDisassembler.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCSubtargetInfo.h"
+#include "llvm/Support/MathExtras.h"
+#include "llvm/Support/TargetRegistry.h"
+#include <cassert>
+#include <cstdint>
+
+using namespace llvm;
+
+#define DEBUG_TYPE "m88k-disassembler"
+
+using DecodeStatus = MCDisassembler::DecodeStatus;
+
+namespace {
+
+class M88kDisassembler : public MCDisassembler {
+public:
+  M88kDisassembler(const MCSubtargetInfo &STI, MCContext &Ctx)
+      : MCDisassembler(STI, Ctx) {}
+  ~M88kDisassembler() override = default;
+
+  DecodeStatus getInstruction(MCInst &instr, uint64_t &Size,
+                              ArrayRef<uint8_t> Bytes, uint64_t Address,
+                              raw_ostream &CStream) const override;
+};
+
+} // end anonymous namespace
+
+static MCDisassembler *createM88kDisassembler(const Target &T,
+                                              const MCSubtargetInfo &STI,
+                                              MCContext &Ctx) {
+  return new M88kDisassembler(STI, Ctx);
+}
+
+extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kDisassembler() {
+  // Register the disassembler.
+  TargetRegistry::RegisterMCDisassembler(getTheM88kTarget(),
+                                         createM88kDisassembler);
+}
+
+static const uint16_t GPRDecoderTable[] = {
+    M88k::R0,  M88k::R1,  M88k::R2,  M88k::R3,  M88k::R4,  M88k::R5,
+    M88k::R6,  M88k::R7,  M88k::R8,  M88k::R9,  M88k::R10, M88k::R11,
+    M88k::R12, M88k::R13, M88k::R14, M88k::R15,
+
+    M88k::R16, M88k::R17, M88k::R18, M88k::R19, M88k::R20, M88k::R21,
+    M88k::R22, M88k::R23, M88k::R24, M88k::R25, M88k::R26, M88k::R27,
+    M88k::R28, M88k::R29, M88k::R30, M88k::R31,
+};
+
+static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
+                                           uint64_t Address,
+                                           const void *Decoder) {
+  if (RegNo > 31)
+    return MCDisassembler::Fail;
+
+  unsigned Register = GPRDecoderTable[RegNo];
+  Inst.addOperand(MCOperand::createReg(Register));
+  return MCDisassembler::Success;
+}
+
+template <unsigned N>
+static DecodeStatus decodeUImmOperand(MCInst &Inst, uint64_t Imm) {
+  if (!isUInt<N>(Imm))
+    return MCDisassembler::Fail;
+  Inst.addOperand(MCOperand::createImm(Imm));
+  return MCDisassembler::Success;
+}
+
+static DecodeStatus decodeU5ImmOOperand(MCInst &Inst, uint64_t Imm,
+                                        uint64_t Address, const void *Decoder) {
+  return decodeUImmOperand<5>(Inst, Imm);
+}
+
+static DecodeStatus decodeU10ImmWOOperand(MCInst &Inst, uint64_t Imm,
+                                          uint64_t Address,
+                                          const void *Decoder) {
+  return decodeUImmOperand<10>(Inst, Imm);
+}
+
+static DecodeStatus decodeU16ImmOperand(MCInst &Inst, uint64_t Imm,
+                                        uint64_t Address, const void *Decoder) {
+  return decodeUImmOperand<16>(Inst, Imm);
+}
+
+static DecodeStatus decodePC26BranchOperand(MCInst &Inst, uint64_t Imm,
+                                            uint64_t Address,
+                                            const void *Decoder) {
+  if (!isUInt<26>(Imm))
+    return MCDisassembler::Fail;
+  Inst.addOperand(MCOperand::createImm(SignExtend64<26>(Imm)));
+  return MCDisassembler::Success;
+}
+
+#include "M88kGenDisassemblerTables.inc"
+
+DecodeStatus M88kDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
+                                              ArrayRef<uint8_t> Bytes,
+                                              uint64_t Address,
+                                              raw_ostream &CS) const {
+  // Instruction size is always 32 bit.
+  if (Bytes.size() < 4) {
+    Size = 0;
+    return MCDisassembler::Fail;
+  }
+  Size = 4;
+
+  // Construct the instruction.
+  uint32_t Inst = 0;
+  for (uint32_t I = 0; I < Size; ++I)
+    Inst = (Inst << 8) | Bytes[I];
+
+  return decodeInstruction(DecoderTableM88k32, MI, Inst, Address, this, STI);
+}
diff --git a/llvm/lib/Target/M88k/M88k.h b/llvm/lib/Target/M88k/M88k.h
new file mode 100644
index 000000000000..48f858fb8727
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88k.h
@@ -0,0 +1,28 @@
+//===-- M88k.h - Top-level interface for M88k representation ----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the entry points for global functions defined in the LLVM
+// M88k back-end.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88K_H
+#define LLVM_LIB_TARGET_M88K_M88K_H
+
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Target/TargetMachine.h"
+
+namespace llvm {
+class M88kTargetMachine;
+class FunctionPass;
+
+FunctionPass *createM88kISelDag(M88kTargetMachine &TM,
+                                CodeGenOpt::Level OptLevel);
+} // end namespace llvm
+#endif
diff --git a/llvm/lib/Target/M88k/M88k.td b/llvm/lib/Target/M88k/M88k.td
new file mode 100644
index 000000000000..efbcf68e575d
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88k.td
@@ -0,0 +1,61 @@
+//===-- M88k.td - Describe the M88000 Target Machine -------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Target-independent interfaces which we are implementing
+//===----------------------------------------------------------------------===//
+
+include "llvm/Target/Target.td"
+
+//===----------------------------------------------------------------------===//
+// M88k Subtarget features.
+//
+
+//===----------------------------------------------------------------------===//
+// Register File, Calling Conv, Instruction Descriptions
+//===----------------------------------------------------------------------===//
+
+include "M88kRegisterInfo.td"
+include "M88kCallingConv.td"
+include "M88kSchedule.td"
+include "M88kInstrFormats.td"
+include "M88kInstrInfo.td"
+
+//===----------------------------------------------------------------------===//
+// M88k processors supported.
+//===----------------------------------------------------------------------===//
+
+def : ProcessorModel<"mc88100", M88kSchedModel, []>;
+def : ProcessorModel<"mc88110", M88kSchedModel, []>;
+
+//===----------------------------------------------------------------------===//
+// Declare the target which we are implementing
+//===----------------------------------------------------------------------===//
+
+def M88kInstrInfo : InstrInfo;
+def M88kAsmParser : AsmParser;
+def M88kAsmParserVariant : AsmParserVariant {
+  let RegisterPrefix = "%";
+}
+
+def M88kAsmWriter : AsmWriter {
+  string AsmWriterClassName  = "InstPrinter";
+  int PassSubtarget = 1;
+  int Variant = 0;
+}
+
+def M88k : Target {
+  let InstructionSet = M88kInstrInfo;
+  let AssemblyParsers  = [M88kAsmParser];
+  let AssemblyParserVariants = [M88kAsmParserVariant];
+  let AssemblyWriters = [M88kAsmWriter];
+  let AllowRegisterRenaming = 1;
+}
diff --git a/llvm/lib/Target/M88k/M88kAsmPrinter.cpp b/llvm/lib/Target/M88k/M88kAsmPrinter.cpp
new file mode 100644
index 000000000000..1fd6bf5ac448
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kAsmPrinter.cpp
@@ -0,0 +1,93 @@
+//===-- M88kAsmPrinter.cpp - M88k LLVM assembly writer ----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains a printer that converts from our internal representation
+// of machine-dependent LLVM code to GAS-format M88k assembly language.
+//
+//===----------------------------------------------------------------------===//
+
+#include "MCTargetDesc/M88kInstPrinter.h"
+//#include "MCTargetDesc/M88kMCExpr.h"
+//#include "MCTargetDesc/M88kTargetStreamer.h"
+#include "M88k.h"
+#include "M88kInstrInfo.h"
+#include "M88kMCInstLower.h"
+#include "M88kTargetMachine.h"
+#include "TargetInfo/M88kTargetInfo.h"
+#include "llvm/CodeGen/AsmPrinter.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineModuleInfoImpls.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "llvm/IR/Mangler.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCInstBuilder.h"
+#include "llvm/MC/MCStreamer.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/Support/TargetRegistry.h"
+#include "llvm/Support/raw_ostream.h"
+using namespace llvm;
+
+#define DEBUG_TYPE "asm-printer"
+
+// TODO:
+// %hi16() and %lo16() for addresses
+
+namespace {
+class M88kAsmPrinter : public AsmPrinter {
+#if 0
+    M88kTargetStreamer &getTargetStreamer() {
+      return static_cast<M88kTargetStreamer &>(
+          *OutStreamer->getTargetStreamer());
+    }
+#endif
+public:
+  explicit M88kAsmPrinter(TargetMachine &TM,
+                          std::unique_ptr<MCStreamer> Streamer)
+      : AsmPrinter(TM, std::move(Streamer)) {}
+
+  StringRef getPassName() const override { return "M88k Assembly Printer"; }
+
+  bool PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
+                       const char *ExtraCode, raw_ostream &OS) override;
+  void emitInstruction(const MachineInstr *MI) override;
+};
+} // end of anonymous namespace
+
+bool M88kAsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
+                                     const char *ExtraCode, raw_ostream &OS) {
+  if (ExtraCode)
+    return AsmPrinter::PrintAsmOperand(MI, OpNo, ExtraCode, OS);
+  M88kMCInstLower Lower(MF->getContext(), *this);
+  MCOperand MO(Lower.lowerOperand(MI->getOperand(OpNo)));
+  M88kInstPrinter::printOperand(MO, MAI, OS);
+  return false;
+}
+
+void M88kAsmPrinter::emitInstruction(const MachineInstr *MI) {
+  MCInst LoweredMI;
+  switch (MI->getOpcode()) {
+  case M88k::RET:
+    LoweredMI = MCInstBuilder(M88k::JMP).addReg(M88k::R1);
+    break;
+
+  default:
+    M88kMCInstLower Lower(MF->getContext(), *this);
+    Lower.lower(MI, LoweredMI);
+    // doLowerInstr(MI, LoweredMI);
+    break;
+  }
+  EmitToStreamer(*OutStreamer, LoweredMI);
+}
+
+// Force static initialization.
+extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kAsmPrinter() {
+  RegisterAsmPrinter<M88kAsmPrinter> X(getTheM88kTarget());
+}
diff --git a/llvm/lib/Target/M88k/M88kCallingConv.td b/llvm/lib/Target/M88k/M88kCallingConv.td
new file mode 100644
index 000000000000..bd5d4cb59eb2
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kCallingConv.td
@@ -0,0 +1,37 @@
+//===-- M88kCallingConv.td - M88k Calling Conventions ------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This describes the calling conventions for the M88k architectures.
+// Only the OpenBSD variant is supported.
+//
+//===----------------------------------------------------------------------===//
+
+// M88k 32-bit ELF C Calling convention.
+def CC_M88k : CallingConv<[
+  // Promote i8/i16 args to i32.
+  CCIfType<[i1, i8, i16], CCPromoteToType<i32>>,
+
+  // Register R12 is used to pass structure return pointer.
+  CCIfSRet<CCIfType<[i32], CCAssignToReg<[R12]>>>,
+
+  // Registers R2 to R9 are used for passing parameters.
+  CCIfType<[i32,i64,f32,f64], CCAssignToReg<[R2, R3, R4, R5, R6, R7, R8, R9]>>,
+
+  // Other arguments are passed on the stack, at least 4-byte-aligned.
+  CCAssignToStack<4, 4>
+]>;
+
+// M88k 32-bit ELF C return-value convention.
+def RetCC_M88k : CallingConv<[
+  // 32-bit values are returned in R2, 64-bit values in pair R2/R3.
+  CCIfType<[i32,f32], CCAssignToReg<[R2]>>,
+  CCIfType<[i64,f64], CCAssignToReg<[R2, R3]>>
+]>;
+
+// M88k 32-bit ELF C callee saved registers.
+def CSR_M88k : CalleeSavedRegs<(add (sequence "R%d", 14, 25), R30)>;
diff --git a/llvm/lib/Target/M88k/M88kCondCode.h b/llvm/lib/Target/M88k/M88kCondCode.h
new file mode 100644
index 000000000000..baaaa1aaf41a
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kCondCode.h
@@ -0,0 +1,40 @@
+//===-- M88kCondCode.h - M88k Condition Code definition --- -----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interfaces that M88k uses to lower LLVM code into a
+// selection DAG.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KCONDCODE_H
+#define LLVM_LIB_TARGET_M88K_M88KCONDCODE_H
+
+namespace llvm {
+
+namespace M88kCC {
+enum CondCode : unsigned {
+  EQ = (1 << 2),  // Equal
+  NE = (1 << 3),  // Not equal
+  GT = (1 << 4),  // Signed greater than
+  LE = (1 << 5),  // Signed less than or equal
+  LT = (1 << 6),  // Signed less than
+  GE = (1 << 7),  // Signed greater than or equal
+  HI = (1 << 8),  // Unsigned greater than
+  LS = (1 << 9),  // Unsigned less than or equal
+  LO = (1 << 10), // Unsigned less than
+  HS = (1 << 11), // Unsigned greater than or equal
+  BE = (1 << 12), // Byte equal
+  NB = (1 << 13), // No byte equal
+  HE = (1 << 14), // Half-word equal
+  NH = (1 << 15), // No half-word equal
+};
+} // end namespace M88kCC
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/M88kFrameLowering.cpp b/llvm/lib/Target/M88k/M88kFrameLowering.cpp
new file mode 100644
index 000000000000..a37a8a8f6cdf
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kFrameLowering.cpp
@@ -0,0 +1,35 @@
+//===-- M88kFrameLowering.cpp - Frame lowering for M88k -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kFrameLowering.h"
+//#include "M88kCallingConv.h"
+//#include "M88kInstrBuilder.h"
+//#include "M88kInstrInfo.h"
+//#include "M88kMachineFunctionInfo.h"
+#include "M88kRegisterInfo.h"
+#include "M88kSubtarget.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/RegisterScavenging.h"
+#include "llvm/IR/Function.h"
+#include "llvm/Target/TargetMachine.h"
+
+using namespace llvm;
+
+M88kFrameLowering::M88kFrameLowering()
+    : TargetFrameLowering(TargetFrameLowering::StackGrowsDown, Align(8), 0,
+                          Align(8), false /* StackRealignable */),
+      RegSpillOffsets(0) {}
+
+void M88kFrameLowering::emitPrologue(MachineFunction &MF,
+                                     MachineBasicBlock &MBB) const {}
+
+void M88kFrameLowering::emitEpilogue(MachineFunction &MF,
+                                     MachineBasicBlock &MBB) const {}
+
+bool M88kFrameLowering::hasFP(const MachineFunction &MF) const { return false; }
diff --git a/llvm/lib/Target/M88k/M88kFrameLowering.h b/llvm/lib/Target/M88k/M88kFrameLowering.h
new file mode 100644
index 000000000000..eee3b1fa075c
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kFrameLowering.h
@@ -0,0 +1,32 @@
+//===-- M88kFrameLowering.h - Frame lowering for M88k -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KFRAMELOWERING_H
+#define LLVM_LIB_TARGET_M88K_M88KFRAMELOWERING_H
+
+#include "llvm/ADT/IndexedMap.h"
+#include "llvm/CodeGen/TargetFrameLowering.h"
+
+namespace llvm {
+class M88kTargetMachine;
+class M88kSubtarget;
+
+class M88kFrameLowering : public TargetFrameLowering {
+  IndexedMap<unsigned> RegSpillOffsets;
+
+public:
+  M88kFrameLowering();
+
+  // Override TargetFrameLowering.
+  void emitPrologue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
+  void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
+  bool hasFP(const MachineFunction &MF) const override;
+};
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/M88kISelDAGToDAG.cpp b/llvm/lib/Target/M88k/M88kISelDAGToDAG.cpp
new file mode 100644
index 000000000000..86ab88f8d893
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kISelDAGToDAG.cpp
@@ -0,0 +1,79 @@
+//===-- M88kISelDAGToDAG.cpp - A dag to dag inst selector for M88k --------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines an instruction selector for the M88k target.
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kTargetMachine.h"
+//#include "M88kISelLowering.h"
+#include "M88k.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+#include "llvm/CodeGen/SelectionDAGISel.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/KnownBits.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "m88k-isel"
+
+namespace {
+
+class M88kDAGToDAGISel : public SelectionDAGISel {
+  const M88kSubtarget *Subtarget;
+
+  const M88kTargetMachine &getTargetMachine() const {
+    return static_cast<const M88kTargetMachine &>(TM);
+  }
+
+  //  const M88kInstrInfo *getInstrInfo() const {
+  //    return Subtarget->getInstrInfo();
+  //  }
+
+public:
+  M88kDAGToDAGISel(M88kTargetMachine &TM, CodeGenOpt::Level OptLevel)
+      : SelectionDAGISel(TM, OptLevel) {}
+
+/*
+  bool runOnMachineFunction(MachineFunction &MF) override {
+    Subtarget = &MF.getSubtarget<M88kSubtarget>();
+    return SelectionDAGISel::runOnMachineFunction(MF);
+  }
+*/
+  // Override MachineFunctionPass.
+  StringRef getPassName() const override {
+    return "M88k DAG->DAG Pattern Instruction Selection";
+  }
+
+  // Override SelectionDAGISel.
+  void Select(SDNode *Node) override;
+/*
+bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
+                                  std::vector<SDValue> &OutOps) override;
+bool IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const override;
+void PreprocessISelDAG() override;
+*/
+
+// Include the pieces autogenerated from the target description.
+#include "M88kGenDAGISel.inc"
+};
+} // end anonymous namespace
+
+FunctionPass *llvm::createM88kISelDag(M88kTargetMachine &TM,
+                                      CodeGenOpt::Level OptLevel) {
+  return new M88kDAGToDAGISel(TM, OptLevel);
+}
+
+void M88kDAGToDAGISel::Select(SDNode *Node) {
+  // Instruction Selection not handled by the auto-generated tablegen selection
+  // should be handled here.
+
+  // Select the default instruction.
+  SelectCode(Node);
+}
diff --git a/llvm/lib/Target/M88k/M88kISelLowering.cpp b/llvm/lib/Target/M88k/M88kISelLowering.cpp
new file mode 100644
index 000000000000..42e4ef5e16ad
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kISelLowering.cpp
@@ -0,0 +1,396 @@
+//===-- M88kISelLowering.cpp - M88k DAG lowering implementation -----===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the M88kTargetLowering class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kISelLowering.h"
+#include "M88kCondCode.h"
+//#include "M88kCallingConv.h"
+//#include "M88kConstantPoolValue.h"
+//#include "M88kMachineFunctionInfo.h"
+#include "M88kTargetMachine.h"
+#include "llvm/CodeGen/CallingConvLower.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IR/Intrinsics.h"
+//#include "llvm/IR/IntrinsicsM88k.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/KnownBits.h"
+#include <cctype>
+
+using namespace llvm;
+
+#define DEBUG_TYPE "m88k-lower"
+
+// If I is a shifted mask, set the size (Width) and the first bit of the
+// mask (Offset), and return true.
+// For example, if I is 0x003e, (Width, Offset) = (5, 1).
+static bool isShiftedMask(uint64_t I, uint64_t &Width, uint64_t &Offset) {
+  if (!isShiftedMask_64(I))
+    return false;
+
+  Width = countPopulation(I);
+  Offset = countTrailingZeros(I);
+  return true;
+}
+
+static M88kCC::CondCode ISDCCtoM88kCC(ISD::CondCode isdCC) {
+  switch (isdCC) {
+  case ISD::SETUEQ:
+    return M88kCC::EQ;
+  case ISD::SETUGT:
+    return M88kCC::HI;
+  case ISD::SETUGE:
+    return M88kCC::HS;
+  case ISD::SETULT:
+    return M88kCC::LO;
+  case ISD::SETULE:
+    return M88kCC::LS;
+  case ISD::SETUNE:
+    return M88kCC::NE;
+  case ISD::SETEQ:
+    return M88kCC::EQ;
+  case ISD::SETGT:
+    return M88kCC::GT;
+  case ISD::SETGE:
+    return M88kCC::GE;
+  case ISD::SETLT:
+    return M88kCC::LT;
+  case ISD::SETLE:
+    return M88kCC::LE;
+  case ISD::SETNE:
+    return M88kCC::NE;
+  default:
+    llvm_unreachable("Unhandled ISDCC code.");
+  }
+}
+
+M88kTargetLowering::M88kTargetLowering(const TargetMachine &TM,
+                                       const M88kSubtarget &STI)
+    : TargetLowering(TM), Subtarget(STI) {
+  addRegisterClass(MVT::i32, &M88k::GPRRegClass);
+
+  // Compute derived properties from the register classes
+  computeRegisterProperties(Subtarget.getRegisterInfo());
+
+  // Set up special registers.
+  setStackPointerRegisterToSaveRestore(M88k::R31);
+
+  // How we extend i1 boolean values.
+  setBooleanContents(ZeroOrOneBooleanContent);
+
+  setMinFunctionAlignment(Align(8));
+  setPrefFunctionAlignment(Align(8));
+
+  // setOperationAction(ISD::CTLZ, MVT::i32, Custom);
+  setOperationAction(ISD::CTTZ, MVT::i32, Expand);
+
+  // Special DAG combiner for bit-field operations.
+  setTargetDAGCombine(ISD::AND);
+  setTargetDAGCombine(ISD::OR);
+  setTargetDAGCombine(ISD::SHL);
+}
+
+SDValue M88kTargetLowering::LowerOperation(SDValue Op,
+                                           SelectionDAG &DAG) const {
+  // TODO Implement for ops not covered by patterns in .td files.
+  /*
+    switch (Op.getOpcode())
+    {
+    case ISD::SHL:          return lowerShiftLeft(Op, DAG);
+    }
+  */
+  return SDValue();
+}
+
+namespace {
+SDValue performANDCombine(SDNode *N, TargetLowering::DAGCombinerInfo &DCI) {
+  SelectionDAG &DAG = DCI.DAG;
+  SDValue FirstOperand = N->getOperand(0);
+  unsigned FirstOperandOpc = FirstOperand.getOpcode();
+  // Second operand of and must be a constant.
+  ConstantSDNode *Mask = dyn_cast<ConstantSDNode>(N->getOperand(1));
+  if (!Mask)
+    return SDValue();
+  EVT ValTy = N->getValueType(0);
+  SDLoc DL(N);
+
+  SDValue NewOperand;
+  unsigned Opc;
+
+  uint64_t Offset;
+  uint64_t MaskWidth, MaskOffset;
+  if (isShiftedMask(Mask->getZExtValue(), MaskWidth, MaskOffset)) {
+    if (FirstOperandOpc == ISD::SRL || FirstOperandOpc == ISD::SRA) {
+      // Pattern match:
+      // $dst = and (srl/sra $src, offset), (2**width - 1)
+      // => EXTU $dst, $src, width<offset>
+
+      // The second operand of the shift must be an immediate.
+      ConstantSDNode *ShiftAmt =
+          dyn_cast<ConstantSDNode>(FirstOperand.getOperand(1));
+      if (!(ShiftAmt))
+        return SDValue();
+
+      Offset = ShiftAmt->getZExtValue();
+
+      // Return if the shifted mask does not start at bit 0 or the sum of its
+      // width and offset exceeds the word's size.
+      if (MaskOffset != 0 || Offset + MaskWidth > ValTy.getSizeInBits())
+        return SDValue();
+
+      Opc = M88kISD::EXTU;
+      NewOperand = FirstOperand.getOperand(0);
+    } else
+      return SDValue();
+  } else if (isShiftedMask(~Mask->getZExtValue() &
+                               ((0x1ULL << ValTy.getSizeInBits()) - 1),
+                           MaskWidth, MaskOffset)) {
+    // Pattern match:
+    // $dst = and $src, ~((2**width - 1) << offset)
+    // => CLR $dst, $src, width<offset>
+    Opc = M88kISD::CLR;
+    NewOperand = FirstOperand;
+    Offset = MaskOffset;
+  } else
+    return SDValue();
+  return DAG.getNode(Opc, DL, ValTy, NewOperand,
+                     DAG.getConstant(MaskWidth << 5 | Offset, DL, MVT::i32));
+}
+
+SDValue performORCombine(SDNode *N, TargetLowering::DAGCombinerInfo &DCI) {
+  SelectionDAG &DAG = DCI.DAG;
+  uint64_t Width, Offset;
+
+  // Second operand of or must be a constant shifted mask.
+  ConstantSDNode *Mask = dyn_cast<ConstantSDNode>(N->getOperand(1));
+  if (!Mask || !isShiftedMask(Mask->getZExtValue(), Width, Offset))
+    return SDValue();
+
+  // Pattern match:
+  // $dst = or $src, ((2**width - 1) << offset
+  // => SET $dst, $src, width<offset>
+  EVT ValTy = N->getValueType(0);
+  SDLoc DL(N);
+  return DAG.getNode(M88kISD::SET, DL, ValTy, N->getOperand(0),
+                     DAG.getConstant(Width << 5 | Offset, DL, MVT::i32));
+}
+
+SDValue performSHLCombine(SDNode *N, TargetLowering::DAGCombinerInfo &DCI) {
+  // Pattern match:
+  // $dst = shl (and $src, (2**width - 1)), offset
+  // => MAK $dst, $src, width<offset>
+  SelectionDAG &DAG = DCI.DAG;
+  SDValue FirstOperand = N->getOperand(0);
+  unsigned FirstOperandOpc = FirstOperand.getOpcode();
+  // First operdns shl must be and, second operand must a constant.
+  ConstantSDNode *ShiftAmt = dyn_cast<ConstantSDNode>(N->getOperand(1));
+  if (!ShiftAmt || FirstOperandOpc != ISD::AND)
+    return SDValue();
+  EVT ValTy = N->getValueType(0);
+  SDLoc DL(N);
+
+  uint64_t Offset;
+  uint64_t MaskWidth, MaskOffset;
+  ConstantSDNode *Mask = dyn_cast<ConstantSDNode>(FirstOperand->getOperand(1));
+  if (!Mask || !isShiftedMask(Mask->getZExtValue(), MaskWidth, MaskOffset))
+    return SDValue();
+
+  // The second operand of the shift must be an immediate.
+  Offset = ShiftAmt->getZExtValue();
+
+  // Return if the shifted mask does not start at bit 0 or the sum of its
+  // width and offset exceeds the word's size.
+  if (MaskOffset != 0 || Offset + MaskWidth > ValTy.getSizeInBits())
+    return SDValue();
+
+  return DAG.getNode(M88kISD::MAK, DL, ValTy, FirstOperand.getOperand(0),
+                     DAG.getConstant(MaskWidth << 5 | Offset, DL, MVT::i32));
+}
+} // namespace
+
+SDValue M88kTargetLowering::PerformDAGCombine(SDNode *N,
+                                              DAGCombinerInfo &DCI) const {
+  if (DCI.isBeforeLegalizeOps())
+    return SDValue();
+  LLVM_DEBUG(dbgs() << "In PerformDAGCombine\n");
+
+  // TODO: Match certain and/or/shift ops to ext/mak.
+  unsigned Opc = N->getOpcode();
+
+  switch (Opc) {
+  default:
+    break;
+  case ISD::AND:
+    return performANDCombine(N, DCI);
+  case ISD::OR:
+    return performORCombine(N, DCI);
+  case ISD::SHL:
+    return performSHLCombine(N, DCI);
+  }
+
+  return SDValue();
+}
+
+//===----------------------------------------------------------------------===//
+// Calling conventions
+//===----------------------------------------------------------------------===//
+
+#include "M88kGenCallingConv.inc"
+
+SDValue M88kTargetLowering::LowerFormalArguments(
+    SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
+    const SmallVectorImpl<ISD::InputArg> &Ins, const SDLoc &DL,
+    SelectionDAG &DAG, SmallVectorImpl<SDValue> &InVals) const {
+
+  MachineFunction &MF = DAG.getMachineFunction();
+  MachineRegisterInfo &MRI = MF.getRegInfo();
+
+  // Assign locations to all of the incoming arguments.
+  SmallVector<CCValAssign, 16> ArgLocs;
+  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
+  CCInfo.AnalyzeFormalArguments(Ins, CC_M88k);
+
+  for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {
+    SDValue ArgValue;
+    CCValAssign &VA = ArgLocs[I];
+    EVT LocVT = VA.getLocVT();
+    if (VA.isRegLoc()) {
+      // Arguments passed in registers
+      const TargetRegisterClass *RC;
+      switch (LocVT.getSimpleVT().SimpleTy) {
+      default:
+        // Integers smaller than i64 should be promoted to i32.
+        llvm_unreachable("Unexpected argument type");
+      case MVT::i32:
+        RC = &M88k::GPRRegClass;
+        break;
+      }
+
+      Register VReg = MRI.createVirtualRegister(RC);
+      MRI.addLiveIn(VA.getLocReg(), VReg);
+      ArgValue = DAG.getCopyFromReg(Chain, DL, VReg, LocVT);
+
+      // If this is an 8/16-bit value, it is really passed promoted to 32
+      // bits. Insert an assert[sz]ext to capture this, then truncate to the
+      // right size.
+      if (VA.getLocInfo() == CCValAssign::SExt)
+        ArgValue = DAG.getNode(ISD::AssertSext, DL, LocVT, ArgValue,
+                               DAG.getValueType(VA.getValVT()));
+      else if (VA.getLocInfo() == CCValAssign::ZExt)
+        ArgValue = DAG.getNode(ISD::AssertZext, DL, LocVT, ArgValue,
+                               DAG.getValueType(VA.getValVT()));
+
+      if (VA.getLocInfo() != CCValAssign::Full)
+        ArgValue = DAG.getNode(ISD::TRUNCATE, DL, VA.getValVT(), ArgValue);
+
+      InVals.push_back(ArgValue);
+    } else {
+      assert(VA.isMemLoc() && "Argument not register or memory");
+      llvm_unreachable(
+          "M88k - LowerFormalArguments - Memory argument not implemented");
+    }
+  }
+
+  if (IsVarArg) {
+    llvm_unreachable("M88k - LowerFormalArguments - VarArgs not Implemented");
+  }
+
+  return Chain;
+}
+
+SDValue
+M88kTargetLowering::LowerReturn(SDValue Chain, CallingConv::ID CallConv,
+                                bool IsVarArg,
+                                const SmallVectorImpl<ISD::OutputArg> &Outs,
+                                const SmallVectorImpl<SDValue> &OutVals,
+                                const SDLoc &DL, SelectionDAG &DAG) const {
+
+  MachineFunction &MF = DAG.getMachineFunction();
+
+  // Assign locations to each returned value.
+  SmallVector<CCValAssign, 16> RetLocs;
+  CCState RetCCInfo(CallConv, IsVarArg, MF, RetLocs, *DAG.getContext());
+  RetCCInfo.AnalyzeReturn(Outs, RetCC_M88k);
+
+  // Quick exit for void returns
+  if (RetLocs.empty())
+    return DAG.getNode(M88kISD::RET_FLAG, DL, MVT::Other, Chain);
+
+  SDValue Glue;
+  SmallVector<SDValue, 4> RetOps;
+  RetOps.push_back(Chain);
+  for (unsigned I = 0, E = RetLocs.size(); I != E; ++I) {
+    CCValAssign &VA = RetLocs[I];
+    SDValue RetValue = OutVals[I];
+
+    // Make the return register live on exit.
+    assert(VA.isRegLoc() && "Can only return in registers!");
+
+    // Promote the value as required.
+    // TODO: Refactor into own method?
+    switch (VA.getLocInfo()) {
+    case CCValAssign::SExt:
+      RetValue = DAG.getNode(ISD::SIGN_EXTEND, DL, VA.getLocVT(), RetValue);
+      break;
+    case CCValAssign::ZExt:
+      RetValue = DAG.getNode(ISD::ZERO_EXTEND, DL, VA.getLocVT(), RetValue);
+      break;
+    case CCValAssign::AExt:
+      RetValue = DAG.getNode(ISD::ANY_EXTEND, DL, VA.getLocVT(), RetValue);
+      break;
+    case CCValAssign::Full:
+      break;
+    default:
+      llvm_unreachable("Unhandled VA.getLocInfo()");
+    }
+
+    // Chain and glue the copies together.
+    Register Reg = VA.getLocReg();
+    Chain = DAG.getCopyToReg(Chain, DL, Reg, RetValue, Glue);
+    Glue = Chain.getValue(1);
+    RetOps.push_back(DAG.getRegister(Reg, VA.getLocVT()));
+  }
+
+  // Update chain and glue.
+  RetOps[0] = Chain;
+  if (Glue.getNode())
+    RetOps.push_back(Glue);
+
+  return DAG.getNode(M88kISD::RET_FLAG, DL, MVT::Other, RetOps);
+}
+
+SDValue M88kTargetLowering::LowerCall(CallLoweringInfo &CLI,
+                                      SmallVectorImpl<SDValue> &InVals) const {
+  llvm_unreachable("M88k - LowerCall - Not Implemented");
+}
+
+const char *M88kTargetLowering::getTargetNodeName(unsigned Opcode) const {
+  switch (Opcode) {
+#define OPCODE(Opc)                                                            \
+  case Opc:                                                                    \
+    return #Opc
+    OPCODE(M88kISD::RET_FLAG);
+    OPCODE(M88kISD::CALL);
+    OPCODE(M88kISD::CLR);
+    OPCODE(M88kISD::SET);
+    OPCODE(M88kISD::EXT);
+    OPCODE(M88kISD::EXTU);
+    OPCODE(M88kISD::MAK);
+    OPCODE(M88kISD::ROT);
+    OPCODE(M88kISD::FF1);
+    OPCODE(M88kISD::FF0);
+#undef OPCODE
+  default:
+    return nullptr;
+  }
+}
diff --git a/llvm/lib/Target/M88k/M88kISelLowering.h b/llvm/lib/Target/M88k/M88kISelLowering.h
new file mode 100644
index 000000000000..83ecbc541806
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kISelLowering.h
@@ -0,0 +1,85 @@
+//===-- M88kISelLowering.h - M88k DAG lowering interface --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interfaces that M88k uses to lower LLVM code into a
+// selection DAG.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KISELLOWERING_H
+#define LLVM_LIB_TARGET_M88K_M88KISELLOWERING_H
+
+#include "M88k.h"
+#include "M88kInstrInfo.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/SelectionDAG.h"
+#include "llvm/CodeGen/TargetLowering.h"
+
+namespace llvm {
+
+class M88kSubtarget;
+class M88kSubtarget;
+
+namespace M88kISD {
+enum NodeType : unsigned {
+  FIRST_NUMBER = ISD::BUILTIN_OP_END,
+
+  // Return with a flag operand.  Operand 0 is the chain operand.
+  RET_FLAG,
+
+  // Calls a function.  Operand 0 is the chain operand and operand 1
+  // is the target address.  The arguments start at operand 2.
+  // There is an optional glue operand at the end.
+  CALL,
+
+  // Bit-field instructions.
+  CLR,
+  SET,
+  EXT,
+  EXTU,
+  MAK,
+  ROT,
+  FF1,
+  FF0,
+};
+} // end namespace M88kISD
+
+class M88kTargetLowering : public TargetLowering {
+  const M88kSubtarget &Subtarget;
+
+public:
+  explicit M88kTargetLowering(const TargetMachine &TM,
+                              const M88kSubtarget &STI);
+
+  // Override TargetLowering methods.
+  bool hasAndNot(SDValue X) const override { return true; }
+  const char *getTargetNodeName(unsigned Opcode) const override;
+
+  SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const override;
+
+  SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const override;
+
+  // Override required hooks.
+  SDValue LowerFormalArguments(SDValue Chain, CallingConv::ID CallConv,
+                               bool IsVarArg,
+                               const SmallVectorImpl<ISD::InputArg> &Ins,
+                               const SDLoc &DL, SelectionDAG &DAG,
+                               SmallVectorImpl<SDValue> &InVals) const override;
+
+  SDValue LowerReturn(SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
+                      const SmallVectorImpl<ISD::OutputArg> &Outs,
+                      const SmallVectorImpl<SDValue> &OutVals, const SDLoc &DL,
+                      SelectionDAG &DAG) const override;
+
+  SDValue LowerCall(CallLoweringInfo &CLI,
+                    SmallVectorImpl<SDValue> &InVals) const override;
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/M88kInstrFormats.td b/llvm/lib/Target/M88k/M88kInstrFormats.td
new file mode 100644
index 000000000000..b21906b8249a
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kInstrFormats.td
@@ -0,0 +1,209 @@
+//===-- M88kInstrFormats.td - M88k Instruction Formats -----*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+class InstM88k<dag outs, dag ins, string asmstr, list<dag> pattern,
+             InstrItinClass itin = NoItinerary>
+   : Instruction {
+  field bits<32> Inst;
+
+  field bits<32> SoftFail = 0; // Needed by disassembler.
+
+  let Namespace = "M88k";
+  let Size = 4;
+
+  dag OutOperandList = outs;
+  dag InOperandList = ins;
+  let AsmString   = asmstr;
+  let Pattern = pattern;
+
+  let DecoderNamespace = "M88k";
+
+  let Itinerary = itin;
+}
+
+class Pseudo<dag outs, dag ins, list<dag> pattern>
+  : InstM88k<outs, ins, "", pattern> {
+  let isCodeGenOnly       = 1;
+  let isPseudo            = 1;
+  let hasNoSchedulingInfo = 1;
+}
+
+// The formats follow the categories specified in the User Manual.
+
+// Category: Logical.
+class F_L<dag outs, dag ins, string asmstr, list<dag> pattern,
+          InstrItinClass itin = NoItinerary>
+   : InstM88k<outs, ins, asmstr, pattern, itin> {
+  bits<5>  rd;
+  bits<5>  rs1;
+  let Inst{25-21} = rd;
+  let Inst{20-16} = rs1;
+}
+
+// Format: Logical with 16bit immediate.
+class F_LI<bits<2> func, bits<1> upper, dag outs, dag ins, string asmstr, list<dag> pattern,
+         InstrItinClass itin = NoItinerary>
+   : F_L<outs, ins, asmstr, pattern, itin> {
+  bits<16> imm16;
+  let Inst{31-29} = 0b010;
+  let Inst{28-27} = func;
+  let Inst{26}    = upper;
+  let Inst{15-0}  = imm16;
+}
+
+// Format: Logical with triadic register.
+class F_LR<bits<5> func, bits<1> comp, dag outs, dag ins, string asmstr, list<dag> pattern,
+         InstrItinClass itin = NoItinerary>
+   : F_L<outs, ins, asmstr, pattern, itin> {
+  bits<5>  rs2;
+  let Inst{31-26} = 0b111101;
+  let Inst{15-11} = func;
+  let Inst{10}    = comp;
+  let Inst{9-5}   = 0b00000;
+  let Inst{4-0}   = rs2;
+}
+
+// Category: Bit-fields.
+class F_B<bits<6> func, dag outs, dag ins, string asmstr, list<dag> pattern,
+         InstrItinClass itin = NoItinerary>
+   : F_L<outs, ins, asmstr, pattern, itin> {
+  let Inst{31-27} = 0b11110;
+  let Inst{15-10} = func;
+}
+
+// Format: Bit-field with triadic register.
+class F_BR<bits<6> func, dag outs, dag ins, string asmstr, list<dag> pattern,
+         InstrItinClass itin = NoItinerary>
+   : F_B<func, outs, ins, asmstr, pattern, itin> {
+  bits<5> rs2;
+  let Inst{26}  = 0b1;
+  let Inst{9-5} = 0b00000;
+  let Inst{4-0} = rs2;
+}
+
+// Format: Bit-field with 10-bit immediate.
+class F_BI<bits<6> func, dag outs, dag ins, string asmstr, list<dag> pattern,
+         InstrItinClass itin = NoItinerary>
+   : F_B<func, outs, ins, asmstr, pattern, itin> {
+  bits<10> w5o5;
+  let Inst{26}  = 0b0;
+  let Inst{9-0} = w5o5;
+}
+
+// Category: Integer.
+class F_I<dag outs, dag ins, string asmstr, list<dag> pattern,
+          InstrItinClass itin = NoItinerary>
+   : InstM88k<outs, ins, asmstr, pattern, itin> {
+  bits<5>  rd;
+  bits<5>  rs1;
+  let Inst{25-21} = rd;
+  let Inst{20-16} = rs1;
+}
+
+// Format: Integer with 16bit immediate.
+class F_II<bits<6> func, dag outs, dag ins, string asmstr, list<dag> pattern,
+           InstrItinClass itin = NoItinerary>
+   : F_I<outs, ins, asmstr, pattern, itin> {
+  bits<16> imm16;
+
+  let Inst{31-26} = func;
+  let Inst{15-0}  = imm16;
+}
+
+// Format: Integer with triadic register and carry.
+class F_IRC<bits<6> func, bits<1> carryin, bits<1> carryout, dag outs, dag ins,
+            string asmstr, list<dag> pattern, InstrItinClass itin = NoItinerary>
+   : F_I<outs, ins, asmstr, pattern, itin> {
+  bits<5> rs2;
+
+  let Inst{31-26} = 0b111101;
+  let Inst{15-10} = func;
+  let Inst{9}     = carryin;
+  let Inst{8}     = carryout;
+  let Inst{7-5}   = 0b000;
+  let Inst{4-0}   = rs2;
+}
+
+// Category: Load/Store/Exchange
+
+// Format: Load/Store with word index
+class F_LSINDEX<dag outs, dag ins, string asmstr, list<dag> pattern,
+                InstrItinClass itin = NoItinerary>
+   : InstM88k<outs, ins, asmstr, pattern, itin> {
+  bits<5>  rd;
+  bits<5>  rs1;
+  bits<16> si16;
+
+  let Inst{25-21} = rd;
+  let Inst{20-16} = rs1;
+  let Inst{15-0}  = si16;
+}
+
+// Format: Load/Store
+class F_LS<bits<4> func, bits<2> ty,
+               dag outs, dag ins, string asmstr, list<dag> pattern,
+               InstrItinClass itin = NoItinerary>
+   : F_LSINDEX<outs, ins, asmstr, pattern, itin> {
+  let Inst{31-28} = func;
+  let Inst{27-26} = ty;
+}
+
+// Format: Load unsigned
+class F_LU<bits<1> b,
+               dag outs, dag ins, string asmstr, list<dag> pattern,
+               InstrItinClass itin = NoItinerary>
+   : F_LSINDEX<outs, ins, asmstr, pattern, itin> {
+  let Inst{31-27} = 0b00001;
+  let Inst{26}    = b;
+}
+
+
+// Category: Flow control.
+
+// Format: JMP/JSR
+class F_JMP<bits<5> func, bits<1> next,
+            dag outs, dag ins, string asmstr, list<dag> pattern,
+            InstrItinClass itin = NoItinerary>
+   : InstM88k<outs, ins, asmstr, pattern, itin> {
+  bits<5> rs2;
+
+  let Inst{31-26} = 0b111101;
+  let Inst{25-16} = 0b0000000000;
+  let Inst{15-11} = func;
+  let Inst{10}    = next;
+  let Inst{9-5}   = 0b00000;
+  let Inst{4-0}   = rs2;
+}
+
+// Format: BR/BSR
+class F_BRANCH<bits<5> func, bits<1> next,
+               dag outs, dag ins, string asmstr, list<dag> pattern,
+               InstrItinClass itin = NoItinerary>
+   : InstM88k<outs, ins, asmstr, pattern, itin> {
+  bits<26> d26;
+
+  let Inst{31-27} = func;
+  let Inst{26}    = next;
+  let Inst{25-0}  = d26;
+}
+
+// Format: BB0/BB1/BCOND
+class F_BCOND<bits<5> func, bits<1> next,
+               dag outs, dag ins, string asmstr, list<dag> pattern,
+               InstrItinClass itin = NoItinerary>
+   : InstM88k<outs, ins, asmstr, pattern, itin> {
+  bits<5>  m5;
+  bits<5>  rs1;
+  bits<16> d16;
+
+  let Inst{31-27} = func;
+  let Inst{26}    = next;
+  let Inst{25-21} = m5;
+  let Inst{20-16} = rs1;
+  let Inst{15-0}  = d16;
+}
diff --git a/llvm/lib/Target/M88k/M88kInstrInfo.cpp b/llvm/lib/Target/M88k/M88kInstrInfo.cpp
new file mode 100644
index 000000000000..20245ae95156
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kInstrInfo.cpp
@@ -0,0 +1,54 @@
+//===-- M88kInstrInfo.cpp - M88k instruction information ------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the M88k implementation of the TargetInstrInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kInstrInfo.h"
+#include "M88k.h"
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+//#include "M88kInstrBuilder.h"
+#include "M88kSubtarget.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/CodeGen/LiveInterval.h"
+#include "llvm/CodeGen/LiveIntervals.h"
+#include "llvm/CodeGen/LiveVariables.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineMemOperand.h"
+#include "llvm/CodeGen/MachineOperand.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/SlotIndexes.h"
+#include "llvm/CodeGen/TargetInstrInfo.h"
+#include "llvm/CodeGen/TargetSubtargetInfo.h"
+#include "llvm/MC/MCInstrDesc.h"
+#include "llvm/MC/MCRegisterInfo.h"
+#include "llvm/Support/BranchProbability.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/MathExtras.h"
+#include "llvm/Target/TargetMachine.h"
+#include <cassert>
+#include <cstdint>
+#include <iterator>
+
+using namespace llvm;
+
+#define GET_INSTRINFO_CTOR_DTOR
+#define GET_INSTRMAP_INFO
+#include "M88kGenInstrInfo.inc"
+
+#define DEBUG_TYPE "m88k-ii"
+
+// Pin the vtable to this file.
+void M88kInstrInfo::anchor() {}
+
+M88kInstrInfo::M88kInstrInfo(M88kSubtarget &STI)
+    : M88kGenInstrInfo(), RI(), STI(STI) {}
diff --git a/llvm/lib/Target/M88k/M88kInstrInfo.h b/llvm/lib/Target/M88k/M88kInstrInfo.h
new file mode 100644
index 000000000000..3e58227f0e78
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kInstrInfo.h
@@ -0,0 +1,47 @@
+//===-- M88kInstrInfo.h - M88k instruction information ----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the M88k implementation of the TargetInstrInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KINSTRINFO_H
+#define LLVM_LIB_TARGET_M88K_M88KINSTRINFO_H
+
+#include "M88k.h"
+#include "M88kRegisterInfo.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/TargetInstrInfo.h"
+#include <cstdint>
+
+#define GET_INSTRINFO_HEADER
+#include "M88kGenInstrInfo.inc"
+
+namespace llvm {
+
+class M88kSubtarget;
+
+class M88kInstrInfo : public M88kGenInstrInfo {
+  const M88kRegisterInfo RI;
+  M88kSubtarget &STI;
+
+  virtual void anchor();
+
+public:
+  explicit M88kInstrInfo(M88kSubtarget &STI);
+
+  // Return the M88kRegisterInfo, which this class owns.
+  const M88kRegisterInfo &getRegisterInfo() const { return RI; }
+};
+
+} // end namespace llvm
+
+#endif // LLVM_LIB_TARGET_M88K_M88KINSTRINFO_H
diff --git a/llvm/lib/Target/M88k/M88kInstrInfo.td b/llvm/lib/Target/M88k/M88kInstrInfo.td
new file mode 100644
index 000000000000..5fd96f7cf6e5
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kInstrInfo.td
@@ -0,0 +1,396 @@
+//===-- M88kInstrInfo.td - M88k Instructions ---------------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file describes the M88k instructions in TableGen format.
+//
+//===----------------------------------------------------------------------===//
+
+// ---------------------------------------------------------------------------//
+// Selection DAG Nodes.
+// ---------------------------------------------------------------------------//
+
+// Selection DAG types.
+
+// These are target-independent nodes, but have target-specific formats.
+def SDT_CallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
+def SDT_CallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
+def SDT_Call         : SDTypeProfile<0, -1, [SDTCisPtrTy<0>]>;
+
+// Selection DAG nodes.
+
+def call             : SDNode<"M88kISD::CALL", SDT_Call,
+                              [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
+                              SDNPVariadic]>;
+def retflag          : SDNode<"M88kISD::RET_FLAG", SDTNone,
+                              [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
+
+def m88k_clr : SDNode<"M88kISD::CLR", SDTIntBinOp>;
+def m88k_set : SDNode<"M88kISD::SET", SDTIntBinOp>;
+def m88k_ext : SDNode<"M88kISD::EXT", SDTIntBinOp>;
+def m88k_extu : SDNode<"M88kISD::EXTU", SDTIntBinOp>;
+def m88k_mak : SDNode<"M88kISD::MAK", SDTIntBinOp>;
+def m88k_rot : SDNode<"M88kISD::ROT", SDTIntBinOp>;
+def m88k_ff1 : SDNode<"M88kISD::FF1", SDTIntBitCountUnaryOp>;
+def m88k_ff0 : SDNode<"M88kISD::FF0", SDTIntBitCountUnaryOp>;
+
+def m88k_bb0 : SDNode<"M88kISD::BB0", SDTIntBinOp>;
+def m88k_bb1 : SDNode<"M88kISD::BB0", SDTIntBinOp>;
+def m88k_bcond : SDNode<"M88kISD::BB0", SDTIntBinOp>;
+
+
+// Hi16 and Lo16 nodes are used to handle global addresses.
+// TODO Name very similar to LO16/HI16
+def Hi16 : SDNode<"M88kISD::Hi16", SDTIntUnaryOp>;
+def Lo16 : SDNode<"M88kISD::Lo16", SDTIntUnaryOp>;
+
+// ---------------------------------------------------------------------------//
+// Operands.
+// ---------------------------------------------------------------------------//
+
+class ImmediateAsmOperand<string name> : AsmOperandClass {
+  let Name = name;
+  let RenderMethod = "addImmOperands";
+}
+
+class ImmediateOp<ValueType vt, string asmop> : Operand<vt> {
+  let PrintMethod = "print"#asmop#"Operand";
+  let DecoderMethod = "decode"#asmop#"Operand";
+  let ParserMatchClass = !cast<AsmOperandClass>(asmop);
+  let OperandType = "OPERAND_IMMEDIATE";
+}
+
+class ImmOpWithPattern<ValueType vt, string asmop, code pred, SDNodeXForm xform,
+      SDNode ImmNode = imm> :
+  ImmediateOp<vt, asmop>, PatLeaf<(vt ImmNode), pred, xform>;
+
+multiclass Immediate<ValueType vt, code pred, SDNodeXForm xform, string asmop> {
+  // def "" : ImmediateOp<vt, asmop>,
+  //          PatLeaf<(vt imm), pred, xform>;
+  def "" : ImmOpWithPattern<vt, asmop, pred, xform>;
+
+//  def _timm : PatLeaf<(vt timm), pred, xform>;
+  def _timm : ImmOpWithPattern<vt, asmop, pred, xform, timm>;
+}
+
+// Constructs an asm operand for a PC-relative address.  SIZE says how
+// many bits there are.
+class PCRelAsmOperand<string size> : ImmediateAsmOperand<"PCRel"#size> {
+  let PredicateMethod = "isImm";
+  let ParserMethod = "parsePCRel"#size;
+}
+
+// Constructs an operand for a PC-relative address with address type VT.
+// ASMOP is the associated asm operand.
+class PCRelOperand<ValueType vt, AsmOperandClass asmop> : Operand<vt> {
+  let PrintMethod = "printPCRelOperand";
+  let ParserMatchClass = asmop;
+  let OperandType = "OPERAND_PCREL";
+}
+
+
+// Signed and unsigned operands.
+def U5Imm : ImmediateAsmOperand<"U5Imm">;
+def U5ImmO : ImmediateAsmOperand<"U5ImmO">  {
+  let ParserMethod = "parseImmWO";
+}
+def U10ImmWO : ImmediateAsmOperand<"U10ImmWO"> {
+  let ParserMethod = "parseImmWO";
+}
+def S16Imm : ImmediateAsmOperand<"S16Imm">;
+def U16Imm : ImmediateAsmOperand<"U16Imm">;
+
+// PC-relative asm operands.
+def PCRel16 : PCRelAsmOperand<"16">;
+def PCRel26 : PCRelAsmOperand<"26">;
+
+// PC-relative offsets of a basic block.  The offset is sign-extended
+// and shifted left by 2 bits.
+def brtarget16 : PCRelOperand<OtherVT, PCRel16> {
+  let EncoderMethod = "getPC16Encoding";
+  let DecoderMethod = "decodePC16BranchOperand";
+}
+
+def brtarget26 : PCRelOperand<OtherVT, PCRel26> {
+  let EncoderMethod = "getPC26Encoding";
+  let DecoderMethod = "decodePC26BranchOperand";
+}
+
+
+// Extracting immediate operands from nodes.
+
+// Bits 0-15.
+def LO16 : SDNodeXForm<imm, [{
+  uint32_t Value = N->getZExtValue() & 0x000000000000FFFFULL;
+  return CurDAG->getTargetConstant(Value, SDLoc(N), MVT::i32);
+}]>;
+
+// Bits 16-31 (counting from the lsb).
+def HI16 : SDNodeXForm<imm, [{
+  uint64_t Value = (N->getZExtValue() & 0x00000000FFFF0000ULL) >> 16;
+  return CurDAG->getTargetConstant(Value, SDLoc(N), MVT::i32);
+}]>;
+
+
+// Immediates for the lower and upper 16 bits of an i32, with the other
+// bits of the i32 being zero.
+defm imm32lo16 : Immediate<i32, [{
+  return (N->getZExtValue() & ~0x000000000000ffffULL) == 0;
+}], LO16, "U16Imm">;
+
+defm imm32hi16 : Immediate<i32, [{
+  return (N->getZExtValue() & ~0x00000000ffff0000ULL) == 0;
+}], HI16, "U16Imm">;
+
+// Immediates for the lower and upper 16 bits of an i32, with the other
+// bits of the i32 being one.
+defm imm32lo16c : Immediate<i32, [{
+  return (uint32_t(~N->getZExtValue()) & ~0x000000000000ffffULL) == 0;
+}], LO16, "U16Imm">;
+
+defm imm32hi16c : Immediate<i32, [{
+  return (uint32_t(~N->getZExtValue()) & ~0x00000000ffff0000ULL) == 0;
+}], HI16, "U16Imm">;
+
+defm imm32zx5 : Immediate<i32, [{
+  return (N->getZExtValue() & ~0x000000000000001fULL) == 0;
+}], NOOP_SDNodeXForm, "U5Imm">;
+
+defm imm32zx16 : Immediate<i32, [{
+  return (N->getZExtValue() & ~0x00000000000000ffULL) == 0;
+}], NOOP_SDNodeXForm, "U16Imm">;
+
+defm imm32zx5O : Immediate<i32, [{
+  return (N->getZExtValue() & ~0x000000000000001fULL) == 0;
+}], NOOP_SDNodeXForm, "U5ImmO">;
+
+defm imm32zx10WO : Immediate<i32, [{
+  return (N->getZExtValue() & ~0x00000000000003ffULL) == 0;
+}], NOOP_SDNodeXForm, "U10ImmWO">;
+
+// Predicate: Arbitrary 32 bit value.
+def uimm32 : PatLeaf<(imm), [{
+  uint64_t Val = N->getZExtValue();
+  return isUInt<32>(Val) && (Val & 0xffff);
+}]>;
+
+
+// Multiclass for logical instructions with immediates.
+// The pattern for "and" is slightly different.
+multiclass LogicImm<bits<2> FuncI, string OpcStr, SDNode OpNode,
+                  InstrItinClass itin = NoItinerary> {
+  def ri  : F_LI<FuncI, 0b0,
+                 (outs GPROpnd:$rd),
+                 !if(!eq(OpcStr, "and"),
+                   (ins GPROpnd:$rs1, imm32lo16c:$imm16),
+                   (ins GPROpnd:$rs1, imm32lo16:$imm16)
+                 ),
+                 !strconcat(OpcStr, " $rd, $rs1, $imm16"),
+                 !if(!eq(OpcStr, "and"),
+                   [(set i32:$rd, (OpNode GPROpnd:$rs1, imm32lo16c:$imm16))],
+                   [(set i32:$rd, (OpNode GPROpnd:$rs1, imm32lo16:$imm16))]
+                 ),
+                 itin>;
+  def riu  : F_LI<FuncI, 0b1,
+                 (outs GPROpnd:$rd),
+                 !if(!eq(OpcStr, "and"),
+                   (ins GPROpnd:$rs1, imm32hi16c:$imm16),
+                   (ins GPROpnd:$rs1, imm32hi16:$imm16)
+                 ),
+                 !strconcat(OpcStr, ".u $rd, $rs1, $imm16"),
+                 !if(!eq(OpcStr, "and"),
+                   [(set i32:$rd, (OpNode GPROpnd:$rs1, imm32hi16c:$imm16))],
+                   [(set i32:$rd, (OpNode GPROpnd:$rs1, imm32hi16:$imm16))]
+                 ),
+                 itin>;
+}
+
+// Multiclass for logical instructions with triadic registers or immediates.
+multiclass Logic<bits<5> FuncR, bits<2> FuncI, string OpcStr, SDNode OpNode,
+                 InstrItinClass itin = NoItinerary>
+                 : LogicImm<FuncI, OpcStr, OpNode, itin> {
+  let isCommutable = 1 in
+    def rr  : F_LR<FuncR, 0b0,
+                   (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                   !strconcat(OpcStr, " $rd, $rs1, $rs2"),
+                   [(set i32:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                   itin>;
+  def rrc : F_LR<FuncR, 0b1,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 !strconcat(OpcStr, ".c $rd, $rs1, $rs2"),
+                 [(set i32:$rd, (OpNode GPROpnd:$rs1, (not GPROpnd:$rs2)))],
+                 itin>;
+}
+
+defm MASK : LogicImm<0b01, "mask", and>;
+defm AND : Logic<0b01000, 0b00, "and", and>;
+defm XOR : Logic<0b01010, 0b10, "xor", xor>;
+defm OR  : Logic<0b01011, 0b11, "or", or>;
+
+// Pattern for 32 bit constants.
+def : Pat<(and GPR:$rs1, uimm32:$imm),
+          (ANDri (ANDriu GPR:$rs1, (HI16 i32:$imm)), (LO16 i32:$imm))>;
+def : Pat<(or GPR:$rs1, uimm32:$imm),
+          (ORri (ORriu GPR:$rs1, (HI16 i32:$imm)), (LO16 i32:$imm))>;
+def : Pat<(xor GPR:$rs1, uimm32:$imm),
+          (XORri (XORriu GPR:$rs1, (HI16 i32:$imm)), (LO16 i32:$imm))>;
+
+
+// Multiclass for bit-field instructions with triadic registers or immediates.
+multiclass Bitfield<bits<6> Func, string OpcStr, SDNode OpNode, PatLeaf ImmOp,
+                 InstrItinClass itin = NoItinerary> {
+  def rr  : F_BR<Func,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 !strconcat(OpcStr, " $rd, $rs1, $rs2"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                 itin>;
+  def rwo : F_BI<Func,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, ImmOp:$w5o5),
+                 !strconcat(OpcStr, " $rd, $rs1, $w5o5"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, ImmOp:$w5o5))],
+                 itin>;
+}
+
+defm CLR  : Bitfield<0b100000, "clr", m88k_clr, imm32zx10WO>;
+defm SET  : Bitfield<0b100010, "set", m88k_set, imm32zx10WO>;
+defm EXT  : Bitfield<0b100100, "ext", m88k_ext, imm32zx10WO>;
+defm EXTU : Bitfield<0b100110, "extu", m88k_extu, imm32zx10WO>;
+defm MAK  : Bitfield<0b101000, "mak", m88k_mak, imm32zx10WO>;
+defm ROT  : Bitfield<0b101010, "rot", m88k_rot, imm32zx5O>;
+
+// Pattern for shifts
+def : Pat<(sra GPR:$rs1, GPR:$rs2), (EXTrr GPR:$rs1, GPR:$rs2)>;
+def : Pat<(srl GPR:$rs1, GPR:$rs2), (EXTUrr GPR:$rs1, GPR:$rs2)>;
+def : Pat<(shl GPR:$rs1, GPR:$rs2), (MAKrr GPR:$rs1, GPR:$rs2)>;
+def : Pat<(rotr GPR:$rs1, GPR:$rs2), (ROTrr GPR:$rs1, GPR:$rs2)>;
+def : Pat<(sra GPR:$rs1, imm32zx5O:$o5), (EXTrwo GPR:$rs1, imm32zx5O:$o5)>;
+def : Pat<(srl GPR:$rs1, imm32zx5O:$o5), (EXTUrwo GPR:$rs1, imm32zx5O:$o5)>;
+def : Pat<(shl GPR:$rs1, imm32zx5O:$o5), (MAKrwo GPR:$rs1, imm32zx5O:$o5)>;
+def : Pat<(rotr GPR:$rs1, imm32zx5O:$o5), (ROTrwo GPR:$rs1, imm32zx5O:$o5)>;
+
+let rs1 = 0 in
+class FindBF<bits<6> Func, string OpcStr, SDNode OpNode,
+            InstrItinClass itin = NoItinerary> :
+  F_BR<Func, (outs GPROpnd:$rd), (ins GPROpnd:$rs2),
+             !strconcat(OpcStr, " $rd, $rs2"),
+             [(set GPROpnd:$rd, (OpNode GPROpnd:$rs2))],
+             itin>;
+
+def FF1rr : FindBF<0b111010, "ff1", m88k_ff1>;
+def FF0rr : FindBF<0b111011, "ff0", m88k_ff0>;
+
+// ctlz = 32 - ff1
+//def : Pat<(ctlz GPR:$rs1, GPR:$rs2), (SUBri (i32 32), (FF1rr GPR:$rs1, GPR:$rs2))>;
+
+// Multiclass for arithmetic instructions with triadic registers or immediates.
+multiclass Arith<bits<6> Func, string OpcStr, SDNode OpNode,
+                 InstrItinClass itin = NoItinerary> {
+  def rr  : F_IRC<Func, 0b0, 0b0,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 !strconcat(OpcStr, " $rd, $rs1, $rs2"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                 itin>;
+  def rrci  : F_IRC<Func, 0b1, 0b0,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 !strconcat(OpcStr, ".ci $rd, $rs1, $rs2"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                 itin>;
+  def rrco  : F_IRC<Func, 0b0, 0b1,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 !strconcat(OpcStr, ".co $rd, $rs1, $rs2"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                 itin>;
+  def rrcio : F_IRC<Func, 0b1, 0b1,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 !strconcat(OpcStr, ".cio $rd, $rs1, $rs2"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                 itin>;
+  def ri  : F_II<Func,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, imm32zx16:$imm16),
+                 !strconcat(OpcStr, " $rd, $rs1, $imm16"),
+                 [(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, imm32zx16:$imm16))],
+                 itin>;
+}
+
+let isCommutable = 1 in
+defm ADDU : Arith<0b011000, "addu", add>;
+defm SUBU : Arith<0b011001, "subu", sub>;
+
+def CMPrr : F_IRC<0b011111, 0b0, 0b0,
+                 (outs GPROpnd:$rd), (ins GPROpnd:$rs1, GPROpnd:$rs2),
+                 "cmp $rd, $rs1, $rs2",
+                 [], //[(set GPROpnd:$rd, (OpNode GPROpnd:$rs1, GPROpnd:$rs2))],
+                 NoItinerary>;
+
+// Multiclass for load and store instructions.
+multiclass LoadStore<bits<4> Func, string OpcStr, SDNode OpNode,
+                 InstrItinClass itin = NoItinerary> {
+  def riw  : F_LS<Func, 0b01,
+                  (outs GPROpnd:$rd), (ins GPROpnd:$rs1, imm32zx16:$si16),
+                  !strconcat(OpcStr, " $rd, $rs1, $si16"),
+                  [],
+                  itin>;
+  def rib  : F_LS<Func, 0b11,
+                  (outs GPROpnd:$rd), (ins GPROpnd:$rs1, imm32zx16:$si16),
+                  !strconcat(OpcStr, ".b $rd, $rs1, $si16"),
+                  [],
+                  itin>;
+  def rih  : F_LS<Func, 0b10,
+                  (outs GPROpnd:$rd), (ins GPROpnd:$rs1, imm32zx16:$si16),
+                  !strconcat(OpcStr, ".h $rd, $rs1, $si16"),
+                  [],
+                  itin>;
+  def rid  : F_LS<Func, 0b00,
+                  (outs GPROpnd:$rd), (ins GPROpnd:$rs1, imm32zx16:$si16),
+                  !strconcat(OpcStr, ".d $rd, $rs1, $si16"),
+                  [],
+                  itin>;
+}
+
+class LoadUnsigned<bits<1> b, string OpcStr,
+                 InstrItinClass itin = NoItinerary> :
+  F_LU<b, (outs GPROpnd:$rd), (ins GPROpnd:$rs1, imm32zx16:$si16),
+       !strconcat(OpcStr, " $rd, $rs1, $si16"),
+       [],
+       itin>;
+
+defm LD : LoadStore<0b0001, "ld", load>;
+defm ST : LoadStore<0b0010, "st", null_frag>;
+def LDurih : LoadUnsigned<0b0, "ld.hu">;
+def LDurib : LoadUnsigned<0b1, "ld.bu">;
+
+let isTerminator = 1, isBarrier = 1 in {
+  def JMP : F_JMP<0b11000, 0, (outs), (ins GPROpnd:$rs2),
+                  "jmp $rs2", [(brind GPROpnd:$rs2)]>;
+  let hasDelaySlot = 1 in
+    def JMPn : F_JMP<0b11000, 1, (outs), (ins GPROpnd:$rs2),
+                     "jmp.n $rs2", [(brind GPROpnd:$rs2)]>;
+}
+
+let isCall = 1, isTerminator = 1, isBarrier = 1 in {
+  def JSR : F_JMP<0b11001, 0, (outs), (ins GPROpnd:$rs2),
+                  "jsr $rs2", []>;
+  let hasDelaySlot = 1 in
+    def JSRn : F_JMP<0b11001, 1, (outs), (ins GPROpnd:$rs2),
+                     "jsr.n $rs2", []>;
+}
+
+let isReturn = 1, isTerminator = 1, isBarrier = 1, Uses = [R1] in {
+  def RET : Pseudo<(outs), (ins), [(retflag)]>;
+}
+
+let isBranch = 1, isTerminator = 1, isBarrier = 1 in {
+  def BR : F_BRANCH<0b11000, 0, (outs), (ins brtarget26:$d26), "br $d26",
+                    [(br bb:$d26)]>;
+
+  let hasDelaySlot = 1 in
+    def BRn : F_BRANCH<0b11000, 1, (outs), (ins brtarget26:$d26), "br.n $d26",
+                       [(br bb:$d26)]>;
+}
+
+//
+def : InstAlias<"nop", (ORrr R0, R0, R0)>;
diff --git a/llvm/lib/Target/M88k/M88kMCInstLower.cpp b/llvm/lib/Target/M88k/M88kMCInstLower.cpp
new file mode 100644
index 000000000000..1128749baacb
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kMCInstLower.cpp
@@ -0,0 +1,96 @@
+//===-- M88kMCInstLower.cpp - Lower MachineInstr to MCInst ----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kMCInstLower.h"
+#include "llvm/CodeGen/AsmPrinter.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineOperand.h"
+#include "llvm/IR/Mangler.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCStreamer.h"
+
+using namespace llvm;
+
+// Return the VK_* enumeration for MachineOperand target flags Flags.
+static MCSymbolRefExpr::VariantKind getVariantKind(unsigned Flags) {
+  // TODO Implement
+  return MCSymbolRefExpr::VK_None;
+}
+
+M88kMCInstLower::M88kMCInstLower(MCContext &Ctx, AsmPrinter &Printer)
+    : Ctx(Ctx), Printer(Printer) {}
+
+const MCExpr *
+M88kMCInstLower::getExpr(const MachineOperand &MO,
+                         MCSymbolRefExpr::VariantKind Kind) const {
+  const MCSymbol *Symbol;
+  bool HasOffset = true;
+  switch (MO.getType()) {
+  case MachineOperand::MO_MachineBasicBlock:
+    Symbol = MO.getMBB()->getSymbol();
+    HasOffset = false;
+    break;
+
+  case MachineOperand::MO_GlobalAddress:
+    Symbol = Printer.getSymbol(MO.getGlobal());
+    break;
+
+  case MachineOperand::MO_ExternalSymbol:
+    Symbol = Printer.GetExternalSymbolSymbol(MO.getSymbolName());
+    break;
+
+  case MachineOperand::MO_JumpTableIndex:
+    Symbol = Printer.GetJTISymbol(MO.getIndex());
+    HasOffset = false;
+    break;
+
+  case MachineOperand::MO_ConstantPoolIndex:
+    Symbol = Printer.GetCPISymbol(MO.getIndex());
+    break;
+
+  case MachineOperand::MO_BlockAddress:
+    Symbol = Printer.GetBlockAddressSymbol(MO.getBlockAddress());
+    break;
+
+  default:
+    llvm_unreachable("unknown operand type");
+  }
+  const MCExpr *Expr = MCSymbolRefExpr::create(Symbol, Kind, Ctx);
+  if (HasOffset)
+    if (int64_t Offset = MO.getOffset()) {
+      const MCExpr *OffsetExpr = MCConstantExpr::create(Offset, Ctx);
+      Expr = MCBinaryExpr::createAdd(Expr, OffsetExpr, Ctx);
+    }
+  return Expr;
+}
+
+MCOperand M88kMCInstLower::lowerOperand(const MachineOperand &MO) const {
+  switch (MO.getType()) {
+  case MachineOperand::MO_Register:
+    return MCOperand::createReg(MO.getReg());
+
+  case MachineOperand::MO_Immediate:
+    return MCOperand::createImm(MO.getImm());
+
+  default: {
+    MCSymbolRefExpr::VariantKind Kind = getVariantKind(MO.getTargetFlags());
+    return MCOperand::createExpr(getExpr(MO, Kind));
+  }
+  }
+}
+
+void M88kMCInstLower::lower(const MachineInstr *MI, MCInst &OutMI) const {
+  OutMI.setOpcode(MI->getOpcode());
+  for (unsigned I = 0, E = MI->getNumOperands(); I != E; ++I) {
+    const MachineOperand &MO = MI->getOperand(I);
+    // Ignore all implicit register operands.
+    if (!MO.isReg() || !MO.isImplicit())
+      OutMI.addOperand(lowerOperand(MO));
+  }
+}
diff --git a/llvm/lib/Target/M88k/M88kMCInstLower.h b/llvm/lib/Target/M88k/M88kMCInstLower.h
new file mode 100644
index 000000000000..d40ca0d62a56
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kMCInstLower.h
@@ -0,0 +1,43 @@
+//===-- M88kMCInstLower.h - Lower MachineInstr to MCInst -------*- C++ -*--===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KMCINSTLOWER_H
+#define LLVM_LIB_TARGET_M88K_M88KMCINSTLOWER_H
+
+#include "llvm/MC/MCExpr.h"
+#include "llvm/Support/Compiler.h"
+#include "llvm/Support/DataTypes.h"
+
+namespace llvm {
+class AsmPrinter;
+class MCInst;
+class MCOperand;
+class MachineInstr;
+class MachineOperand;
+class Mangler;
+
+class LLVM_LIBRARY_VISIBILITY M88kMCInstLower {
+  MCContext &Ctx;
+  AsmPrinter &Printer;
+
+public:
+  M88kMCInstLower(MCContext &Ctx, AsmPrinter &Printer);
+
+  // Lower MachineInstr MI to MCInst OutMI.
+  void lower(const MachineInstr *MI, MCInst &OutMI) const;
+
+  // Return an MCOperand for MO.
+  MCOperand lowerOperand(const MachineOperand &MO) const;
+
+  // Return an MCExpr for symbolic operand MO with variant kind Kind.
+  const MCExpr *getExpr(const MachineOperand &MO,
+                        MCSymbolRefExpr::VariantKind Kind) const;
+};
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/M88kRegisterInfo.cpp b/llvm/lib/Target/M88k/M88kRegisterInfo.cpp
new file mode 100644
index 000000000000..e6d378ae8578
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kRegisterInfo.cpp
@@ -0,0 +1,54 @@
+//===-- M88kRegisterInfo.cpp - M88k Register Information ------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the M88k implementation of the TargetRegisterInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kRegisterInfo.h"
+#include "M88k.h"
+//#include "M88kMachineFunctionInfo.h"
+#include "M88kSubtarget.h"
+#include "llvm/ADT/BitVector.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/TargetInstrInfo.h"
+#include "llvm/IR/Type.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/ErrorHandling.h"
+
+using namespace llvm;
+
+#define GET_REGINFO_TARGET_DESC
+#include "M88kGenRegisterInfo.inc"
+
+M88kRegisterInfo::M88kRegisterInfo() : M88kGenRegisterInfo(M88k::R1) {}
+
+const MCPhysReg *
+M88kRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
+  return CSR_M88k_SaveList;
+}
+
+BitVector M88kRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
+  BitVector Reserved(getNumRegs());
+
+  // R31 is the stack pointer.
+  Reserved.set(M88k::R31);
+
+  return Reserved;
+}
+
+void M88kRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator MI,
+                                           int SPAdj, unsigned FIOperandNum,
+                                           RegScavenger *RS) const {}
+
+Register M88kRegisterInfo::getFrameRegister(const MachineFunction &MF) const {
+  return M88k::R30;
+}
diff --git a/llvm/lib/Target/M88k/M88kRegisterInfo.h b/llvm/lib/Target/M88k/M88kRegisterInfo.h
new file mode 100644
index 000000000000..a4fed8fb44db
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kRegisterInfo.h
@@ -0,0 +1,52 @@
+//===-- M88kRegisterInfo.h - M88k Register Information Impl -----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the M88k implementation of the TargetRegisterInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KREGISTERINFO_H
+#define LLVM_LIB_TARGET_M88K_M88KREGISTERINFO_H
+
+#include "llvm/CodeGen/TargetRegisterInfo.h"
+
+#define GET_REGINFO_HEADER
+#include "M88kGenRegisterInfo.inc"
+
+namespace llvm {
+
+struct M88kRegisterInfo : public M88kGenRegisterInfo {
+  M88kRegisterInfo();
+
+  /// Code Generation virtual methods...
+  const MCPhysReg *getCalleeSavedRegs(const MachineFunction *MF) const override;
+
+  BitVector getReservedRegs(const MachineFunction &MF) const override;
+
+  void eliminateFrameIndex(MachineBasicBlock::iterator II, int SPAdj,
+                           unsigned FIOperandNum,
+                           RegScavenger *RS = nullptr) const override;
+
+  Register getFrameRegister(const MachineFunction &MF) const override;
+
+#if 0
+  const uint32_t *getCallPreservedMask(const MachineFunction &MF,
+                                       CallingConv::ID CC) const override;
+
+  const uint32_t* getRTCallPreservedMask(CallingConv::ID CC) const;
+
+  const TargetRegisterClass *getPointerRegClass(const MachineFunction &MF,
+                                                unsigned Kind) const override;
+
+  bool canRealignStack(const MachineFunction &MF) const override;
+#endif
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/M88kRegisterInfo.td b/llvm/lib/Target/M88k/M88kRegisterInfo.td
new file mode 100644
index 000000000000..9aff3753caf1
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kRegisterInfo.td
@@ -0,0 +1,26 @@
+//===-- M88kRegisterInfo.td - M88k Register definitions ----*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+class M88kReg<bits<5> Enc, string n> : Register<n> {
+  let HWEncoding{15-5} = 0;
+  let HWEncoding{4-0} = Enc;
+  let Namespace = "M88k";
+}
+
+// General register
+class GRi<bits<5> Enc, string n> : M88kReg<Enc, n>;
+
+// General-purpose registers
+foreach I = 0-31 in {
+  def R#I : GRi<I, "r"#I>;
+}
+
+def GPR : RegisterClass<"M88k", [i32], 32,
+                            (add (sequence "R%u", 0, 31))>;
+
+def GPROpnd : RegisterOperand<GPR>;
\ No newline at end of file
diff --git a/llvm/lib/Target/M88k/M88kSchedule.td b/llvm/lib/Target/M88k/M88kSchedule.td
new file mode 100644
index 000000000000..139404755d1f
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kSchedule.td
@@ -0,0 +1,37 @@
+//===-- M88kSchedule.td - M88k Scheduling Model ------------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+def M88kSchedModel : SchedMachineModel {
+  // The M88110 can issue 2 instructsions.
+  let IssueWidth = 2;
+
+  // In-order CPU.
+  let MicroOpBufferSize = 0;
+
+  //let LoadLatency = ?;
+  //let MispredictPenalty = ?;
+
+  // Not finished yet.
+  let CompleteModel = 0;
+  let NoModel = 1;
+}
+
+def ALU : ProcResource<2> {let BufferSize = 0; }
+def BF :  ProcResource<1> {let BufferSize = 0; }
+//def LS : ProcResource<1> { let BufferSize = 0; }
+
+def ReadALU   : SchedRead;
+def ReadBF    : SchedRead;
+def WriteALU  : SchedWrite;
+def WriteBF   : SchedWrite;
+//def WriteLS   : SchedWrite;
+
+let SchedModel = M88kSchedModel in {
+  def : WriteRes<WriteALU, [ALU]>   { let Latency = 1; }
+  def : WriteRes<WriteBF, [BF]>     { let Latency = 1; }
+}
diff --git a/llvm/lib/Target/M88k/M88kSubtarget.cpp b/llvm/lib/Target/M88k/M88kSubtarget.cpp
new file mode 100644
index 000000000000..9e0ec055ef3b
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kSubtarget.cpp
@@ -0,0 +1,31 @@
+//===-- M88kSubtarget.cpp - M88k Subtarget Information ----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the M88k specific subclass of TargetSubtargetInfo.
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kSubtarget.h"
+#include "M88k.h"
+#include "llvm/Support/MathExtras.h"
+#include "llvm/Support/TargetRegistry.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "m88k-subtarget"
+
+#define GET_SUBTARGETINFO_TARGET_DESC
+#define GET_SUBTARGETINFO_CTOR
+#include "M88kGenSubtargetInfo.inc"
+
+void M88kSubtarget::anchor() {}
+
+M88kSubtarget::M88kSubtarget(const Triple &TT, const std::string &CPU,
+                             const std::string &FS, const TargetMachine &TM)
+    : M88kGenSubtargetInfo(TT, CPU, /*TuneCPU*/ CPU, FS), TargetTriple(TT),
+      InstrInfo(*this), TLInfo(TM, *this), FrameLowering() {}
diff --git a/llvm/lib/Target/M88k/M88kSubtarget.h b/llvm/lib/Target/M88k/M88kSubtarget.h
new file mode 100644
index 000000000000..e09aa76988b1
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kSubtarget.h
@@ -0,0 +1,68 @@
+//===-- M88kSubtarget.h - Define Subtarget for M88k -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the M88k specific subclass of TargetSubtargetInfo.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KSUBTARGET_H
+#define LLVM_LIB_TARGET_M88K_M88KSUBTARGET_H
+
+#include "M88kFrameLowering.h"
+#include "M88kISelLowering.h"
+#include "M88kInstrInfo.h"
+#include "M88kRegisterInfo.h"
+//#include "M88kSelectionDAGInfo.h"
+#include "llvm/CodeGen/SelectionDAGTargetInfo.h"
+#include "llvm/CodeGen/TargetFrameLowering.h"
+#include "llvm/CodeGen/TargetSubtargetInfo.h"
+#include "llvm/IR/DataLayout.h"
+#include <string>
+
+#define GET_SUBTARGETINFO_HEADER
+#include "M88kGenSubtargetInfo.inc"
+
+namespace llvm {
+class StringRef;
+
+class M88kSubtarget : public M88kGenSubtargetInfo {
+  Triple TargetTriple;
+  virtual void anchor();
+
+  M88kInstrInfo InstrInfo;
+  M88kTargetLowering TLInfo;
+  // SelectionDAGTargetInfo TSInfo;
+  M88kFrameLowering FrameLowering;
+
+public:
+  M88kSubtarget(const Triple &TT, const std::string &CPU, const std::string &FS,
+                const TargetMachine &TM);
+
+  // Automatically generated by tblgen.
+  void ParseSubtargetFeatures(StringRef CPU, StringRef TuneCPU, StringRef FS);
+
+  const TargetFrameLowering *getFrameLowering() const override {
+    return &FrameLowering;
+  }
+  const M88kInstrInfo *getInstrInfo() const override { return &InstrInfo; }
+  const M88kRegisterInfo *getRegisterInfo() const override {
+    return &InstrInfo.getRegisterInfo();
+  }
+  const M88kTargetLowering *getTargetLowering() const override {
+    return &TLInfo;
+  }
+#if 0
+  const SelectionDAGTargetInfo *getSelectionDAGInfo() const override {
+    return &TSInfo;
+  }
+#endif
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/M88kTargetMachine.cpp b/llvm/lib/Target/M88k/M88kTargetMachine.cpp
new file mode 100644
index 000000000000..150e2f0b4432
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kTargetMachine.cpp
@@ -0,0 +1,139 @@
+//===-- M88kTargetMachine.cpp - Define TargetMachine for M88k ---*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kTargetMachine.h"
+#include "M88k.h"
+//#include "M88kTargetObjectFile.h"
+#include "TargetInfo/M88kTargetInfo.h"
+#include "llvm/CodeGen/Passes.h"
+#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "llvm/CodeGen/TargetPassConfig.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/Support/TargetRegistry.h"
+
+using namespace llvm;
+
+extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kTarget() {
+  // Register the target.
+  RegisterTargetMachine<M88kTargetMachine> X(getTheM88kTarget());
+}
+
+namespace {
+// TODO: Check.
+std::string computeDataLayout(const Triple &TT, StringRef CPU, StringRef FS) {
+  std::string Ret;
+
+  // Big endian.
+  Ret += "E";
+
+  // Data mangling.
+  Ret += DataLayout::getManglingComponent(TT);
+
+  // Pointers are 32 bit.
+  Ret += "-p:32:8:32";
+
+  // Make sure that global data has at least 16 bits of alignment by
+  // default, so that we can refer to it using LARL.  We don't have any
+  // special requirements for stack variables though.
+  Ret += "-i1:8:16-i8:8:16";
+
+  // 64-bit integers are naturally aligned.
+  Ret += "-i64:64";
+
+  // 128-bit floats are aligned only to 64 bits.
+  Ret += "-f128:64";
+
+  // We prefer 16 bits of aligned for all globals; see above.
+  Ret += "-a:8:16";
+
+  // Integer registers are 32bits.
+  Ret += "-n32";
+
+  return Ret;
+}
+
+// TODO: Check.
+Reloc::Model getEffectiveRelocModel(Optional<Reloc::Model> RM) {
+  if (!RM.hasValue() || *RM == Reloc::DynamicNoPIC)
+    return Reloc::Static;
+  return *RM;
+}
+
+} // namespace
+
+/// Create an M88k architecture model
+M88kTargetMachine::M88kTargetMachine(const Target &T, const Triple &TT,
+                                     StringRef CPU, StringRef FS,
+                                     const TargetOptions &Options,
+                                     Optional<Reloc::Model> RM,
+                                     Optional<CodeModel::Model> CM,
+                                     CodeGenOpt::Level OL, bool JIT)
+    : LLVMTargetMachine(T, computeDataLayout(TT, CPU, FS), TT, CPU, FS, Options,
+                        getEffectiveRelocModel(RM),
+                        getEffectiveCodeModel(CM, CodeModel::Medium), OL),
+      TLOF(std::make_unique<TargetLoweringObjectFileELF>()) {
+  initAsmInfo();
+}
+
+M88kTargetMachine::~M88kTargetMachine() {}
+
+const M88kSubtarget *
+M88kTargetMachine::getSubtargetImpl(const Function &F) const {
+  Attribute CPUAttr = F.getFnAttribute("target-cpu");
+  Attribute FSAttr = F.getFnAttribute("target-features");
+
+  std::string CPU = !CPUAttr.hasAttribute(Attribute::None)
+                        ? CPUAttr.getValueAsString().str()
+                        : TargetCPU;
+  std::string FS = !FSAttr.hasAttribute(Attribute::None)
+                       ? FSAttr.getValueAsString().str()
+                       : TargetFS;
+
+  auto &I = SubtargetMap[CPU + FS];
+  if (!I) {
+    // This needs to be done before we create a new subtarget since any
+    // creation will depend on the TM and the code generation flags on the
+    // function that reside in TargetOptions.
+    resetTargetOptions(F);
+    I = std::make_unique<M88kSubtarget>(TargetTriple, CPU, FS, *this);
+  }
+
+  return I.get();
+}
+
+namespace {
+/// M88k Code Generator Pass Configuration Options.
+class M88kPassConfig : public TargetPassConfig {
+public:
+  M88kPassConfig(M88kTargetMachine &TM, PassManagerBase &PM)
+      : TargetPassConfig(TM, PM) {}
+
+  M88kTargetMachine &getM88kTargetMachine() const {
+    return getTM<M88kTargetMachine>();
+  }
+
+  bool addInstSelector() override;
+  void addPreEmitPass() override;
+};
+} // namespace
+
+TargetPassConfig *M88kTargetMachine::createPassConfig(PassManagerBase &PM) {
+  return new M88kPassConfig(*this, PM);
+}
+
+bool M88kPassConfig::addInstSelector() {
+  addPass(createM88kISelDag(getM88kTargetMachine(), getOptLevel()));
+  return false;
+}
+
+void M88kPassConfig::addPreEmitPass() {
+  // TODO Add pass for div-by-zero check.
+}
diff --git a/llvm/lib/Target/M88k/M88kTargetMachine.h b/llvm/lib/Target/M88k/M88kTargetMachine.h
new file mode 100644
index 000000000000..f58ba573a909
--- /dev/null
+++ b/llvm/lib/Target/M88k/M88kTargetMachine.h
@@ -0,0 +1,49 @@
+//===-- M88kTargetMachine.h - Define TargetMachine for M88k -----*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the M88k specific subclass of TargetMachine.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_M88KTARGETMACHINE_H
+#define LLVM_LIB_TARGET_M88K_M88KTARGETMACHINE_H
+
+#include "M88kSubtarget.h"
+#include "llvm/Target/TargetLoweringObjectFile.h"
+#include "llvm/Target/TargetMachine.h"
+
+namespace llvm {
+
+class M88kTargetMachine : public LLVMTargetMachine {
+  std::unique_ptr<TargetLoweringObjectFile> TLOF;
+  mutable StringMap<std::unique_ptr<M88kSubtarget>> SubtargetMap;
+
+public:
+  M88kTargetMachine(const Target &T, const Triple &TT, StringRef CPU,
+                    StringRef FS, const TargetOptions &Options,
+                    Optional<Reloc::Model> RM, Optional<CodeModel::Model> CM,
+                    CodeGenOpt::Level OL, bool JIT);
+  ~M88kTargetMachine() override;
+  const M88kSubtarget *getSubtargetImpl(const Function &) const override;
+
+  // DO NOT IMPLEMENT: There is no such thing as a valid default subtarget,
+  // subtargets are per-function entities based on the target-specific
+  // attributes of each function.
+  const M88kSubtarget *getSubtargetImpl() const = delete;
+
+  // Override LLVMTargetMachine
+  TargetPassConfig *createPassConfig(PassManagerBase &PM) override;
+  // TargetTransformInfo getTargetTransformInfo(const Function &F) override;
+  TargetLoweringObjectFile *getObjFileLowering() const override {
+    return TLOF.get();
+  }
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/CMakeLists.txt b/llvm/lib/Target/M88k/MCTargetDesc/CMakeLists.txt
new file mode 100644
index 000000000000..dbfe67c54db9
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/CMakeLists.txt
@@ -0,0 +1,8 @@
+add_llvm_component_library(LLVMM88kDesc
+  M88kInstPrinter.cpp
+  M88kMCAsmBackend.cpp
+  M88kMCAsmInfo.cpp
+  M88kMCCodeEmitter.cpp
+  M88kMCObjectWriter.cpp
+  M88kMCTargetDesc.cpp
+  )
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kInstPrinter.cpp b/llvm/lib/Target/M88k/MCTargetDesc/M88kInstPrinter.cpp
new file mode 100644
index 000000000000..0f6d5df46add
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kInstPrinter.cpp
@@ -0,0 +1,109 @@
+//===- M88kInstPrinter.cpp - Convert M88k MCInst to assembly syntax -------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kInstPrinter.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/MathExtras.h"
+#include "llvm/Support/raw_ostream.h"
+#include <cassert>
+#include <cstdint>
+
+using namespace llvm;
+
+#define DEBUG_TYPE "asm-printer"
+
+#include "M88kGenAsmWriter.inc"
+
+void M88kInstPrinter::printOperand(const MCInst *MI, int OpNum,
+                                   const MCSubtargetInfo &STI, raw_ostream &O) {
+  const MCOperand &MO = MI->getOperand(OpNum);
+  if (MO.isReg()) {
+    if (!MO.getReg())
+      O << '0';
+    else
+      O << '%' << getRegisterName(MO.getReg());
+  } else if (MO.isImm())
+    O << MO.getImm();
+  else if (MO.isExpr())
+    MO.getExpr()->print(O, &MAI);
+  else
+    llvm_unreachable("Invalid operand");
+}
+
+void M88kInstPrinter::printOperand(const MCOperand &MO, const MCAsmInfo *MAI,
+                                   raw_ostream &O) {
+  if (MO.isReg()) {
+    if (!MO.getReg())
+      O << '0';
+    else
+      O << '%' << getRegisterName(MO.getReg());
+  } else if (MO.isImm())
+    O << MO.getImm();
+  else if (MO.isExpr())
+    MO.getExpr()->print(O, MAI);
+  else
+    llvm_unreachable("Invalid operand");
+}
+
+void M88kInstPrinter::printU5ImmOperand(const MCInst *MI, int OpNum,
+                                        const MCSubtargetInfo &STI,
+                                        raw_ostream &O) {
+  int64_t Value = MI->getOperand(OpNum).getImm();
+  // assert(isUInt<N>(Value) && "Invalid uimm argument");
+  O << Value;
+}
+
+void M88kInstPrinter::printU5ImmOOperand(const MCInst *MI, int OpNum,
+                                         const MCSubtargetInfo &STI,
+                                         raw_ostream &O) {
+  int64_t Value = MI->getOperand(OpNum).getImm();
+  // assert(isUInt<N>(Value) && "Invalid uimm argument");
+  O << "<" << Value << ">";
+}
+
+void M88kInstPrinter::printU10ImmWOOperand(const MCInst *MI, int OpNum,
+                                           const MCSubtargetInfo &STI,
+                                           raw_ostream &O) {
+  int64_t Value = MI->getOperand(OpNum).getImm();
+  // assert(isUInt<N>(Value) && "Invalid uimm argument");
+  int64_t Width = (Value >> 5) & 0x1f;
+  int64_t Offset = Value & 0x1f;
+  O << Width << "<" << Offset << ">";
+}
+
+void M88kInstPrinter::printU16ImmOperand(const MCInst *MI, int OpNum,
+                                         const MCSubtargetInfo &STI,
+                                         raw_ostream &O) {
+  int64_t Value = MI->getOperand(OpNum).getImm();
+  // assert(isUInt<N>(Value) && "Invalid uimm argument");
+  O << Value;
+}
+
+void M88kInstPrinter::printPCRelOperand(const MCInst *MI, uint64_t Address,
+                                        int OpNum, const MCSubtargetInfo &STI,
+                                        raw_ostream &O) {
+  // TODO
+  const MCOperand &MO = MI->getOperand(OpNum);
+  if (MO.isImm()) {
+    O << "0x";
+    O.write_hex(MO.getImm());
+  } else
+    MO.getExpr()->print(O, &MAI);
+}
+
+void M88kInstPrinter::printInst(const MCInst *MI, uint64_t Address,
+                                StringRef Annot, const MCSubtargetInfo &STI,
+                                raw_ostream &O) {
+  printInstruction(MI, Address, STI, O);
+  printAnnotation(O, Annot);
+}
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kInstPrinter.h b/llvm/lib/Target/M88k/MCTargetDesc/M88kInstPrinter.h
new file mode 100644
index 000000000000..7ca95b35fda2
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kInstPrinter.h
@@ -0,0 +1,61 @@
+//==- M88kInstPrinter.h - Convert M88k MCInst to assembly --------*- C++ -*-==//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This class prints a M88k MCInst to a .s file.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KINSTPRINTER_H
+#define LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KINSTPRINTER_H
+
+#include "llvm/MC/MCInstPrinter.h"
+#include <cstdint>
+
+namespace llvm {
+
+class MCAsmInfo;
+class MCOperand;
+
+class M88kInstPrinter : public MCInstPrinter {
+public:
+  M88kInstPrinter(const MCAsmInfo &MAI, const MCInstrInfo &MII,
+                  const MCRegisterInfo &MRI)
+      : MCInstPrinter(MAI, MII, MRI) {}
+
+  // Automatically generated by tblgen.
+  std::pair<const char *, uint64_t> getMnemonic(const MCInst *MI) override;
+  void printInstruction(const MCInst *MI, uint64_t Address,
+                        const MCSubtargetInfo &STI, raw_ostream &O);
+  static const char *getRegisterName(unsigned RegNo);
+
+  // Print the given operand.
+  void printOperand(const MCInst *MI, int OpNum, const MCSubtargetInfo &STI,
+                    raw_ostream &O);
+  static void printOperand(const MCOperand &MO, const MCAsmInfo *MAI,
+                           raw_ostream &O);
+
+  void printU5ImmOperand(const MCInst *MI, int OpNum,
+                         const MCSubtargetInfo &STI, raw_ostream &O);
+  void printU5ImmOOperand(const MCInst *MI, int OpNum,
+                          const MCSubtargetInfo &STI, raw_ostream &O);
+  void printU10ImmWOOperand(const MCInst *MI, int OpNum,
+                            const MCSubtargetInfo &STI, raw_ostream &O);
+  void printU16ImmOperand(const MCInst *MI, int OpNum,
+                          const MCSubtargetInfo &STI, raw_ostream &O);
+  void printPCRelOperand(const MCInst *MI, uint64_t Address, int OpNum,
+                         const MCSubtargetInfo &STI, raw_ostream &O);
+
+  // Override MCInstPrinter.
+  // void printRegName(raw_ostream &O, unsigned RegNo) const override;
+  void printInst(const MCInst *MI, uint64_t Address, StringRef Annot,
+                 const MCSubtargetInfo &STI, raw_ostream &O) override;
+};
+
+} // end namespace llvm
+
+#endif // LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KINSTPRINTER_H
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmBackend.cpp b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmBackend.cpp
new file mode 100644
index 000000000000..3c528dd73994
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmBackend.cpp
@@ -0,0 +1,77 @@
+//===-- M88kMCAsmBackend.cpp - M88k assembler backend ---------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+//#include "MCTargetDesc/M88kMCFixups.h"
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+#include "llvm/MC/MCAsmBackend.h"
+#include "llvm/MC/MCELFObjectWriter.h"
+#include "llvm/MC/MCFixupKindInfo.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCObjectWriter.h"
+#include "llvm/MC/MCSubtargetInfo.h"
+
+using namespace llvm;
+
+namespace {
+class M88kMCAsmBackend : public MCAsmBackend {
+  uint8_t OSABI;
+
+public:
+  M88kMCAsmBackend(uint8_t osABI) : MCAsmBackend(support::big), OSABI(osABI) {}
+
+  // Override MCAsmBackend
+  unsigned getNumFixupKinds() const override {
+    return 0; // M88k::NumTargetFixupKinds;
+  }
+  const MCFixupKindInfo &getFixupKindInfo(MCFixupKind Kind) const override;
+  void applyFixup(const MCAssembler &Asm, const MCFixup &Fixup,
+                  const MCValue &Target, MutableArrayRef<char> Data,
+                  uint64_t Value, bool IsResolved,
+                  const MCSubtargetInfo *STI) const override;
+  bool mayNeedRelaxation(const MCInst &Inst,
+                         const MCSubtargetInfo &STI) const override {
+    return false;
+  }
+  bool fixupNeedsRelaxation(const MCFixup &Fixup, uint64_t Value,
+                            const MCRelaxableFragment *Fragment,
+                            const MCAsmLayout &Layout) const override {
+    return false;
+  }
+  bool writeNopData(raw_ostream &OS, uint64_t Count) const override;
+  std::unique_ptr<MCObjectTargetWriter>
+  createObjectTargetWriter() const override {
+    return createM88kObjectWriter(OSABI);
+  }
+};
+} // end anonymous namespace
+
+const MCFixupKindInfo &
+M88kMCAsmBackend::getFixupKindInfo(MCFixupKind Kind) const {
+  return MCAsmBackend::getFixupKindInfo(Kind);
+}
+
+void M88kMCAsmBackend::applyFixup(const MCAssembler &Asm, const MCFixup &Fixup,
+                                  const MCValue &Target,
+                                  MutableArrayRef<char> Data, uint64_t Value,
+                                  bool IsResolved,
+                                  const MCSubtargetInfo *STI) const {}
+
+bool M88kMCAsmBackend::writeNopData(raw_ostream &OS, uint64_t Count) const {
+  for (uint64_t I = 0; I != Count; ++I)
+    OS << '\x7';
+  return true;
+}
+
+MCAsmBackend *llvm::createM88kMCAsmBackend(const Target &T,
+                                           const MCSubtargetInfo &STI,
+                                           const MCRegisterInfo &MRI,
+                                           const MCTargetOptions &Options) {
+  uint8_t OSABI =
+      MCELFObjectTargetWriter::getOSABI(STI.getTargetTriple().getOS());
+  return new M88kMCAsmBackend(OSABI);
+}
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmInfo.cpp b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmInfo.cpp
new file mode 100644
index 000000000000..ee0520305d05
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmInfo.cpp
@@ -0,0 +1,29 @@
+//===-- M88kMCAsmInfo.cpp - M88k asm properties ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kMCAsmInfo.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCSectionELF.h"
+
+using namespace llvm;
+
+M88kMCAsmInfo::M88kMCAsmInfo(const Triple &TT) {
+  // TODO: Check!
+  CodePointerSize = 4;
+  CalleeSaveStackSlotSize = 4;
+  IsLittleEndian = false;
+  UseDotAlignForAlignment = true;
+  MinInstAlignment = 4;
+
+  CommentString = "#";
+  ZeroDirective = "\t.space\t";
+  Data64bitsDirective = "\t.quad\t";
+  UsesELFSectionDirectiveForBSS = true;
+  SupportsDebugInformation = true;
+  ExceptionsType = ExceptionHandling::DwarfCFI;
+}
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmInfo.h b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmInfo.h
new file mode 100644
index 000000000000..d1d975d904fc
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCAsmInfo.h
@@ -0,0 +1,25 @@
+//====-- M88kMCAsmInfo.h - M88k asm properties ---------------*- C++ -*--===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KMCASMINFO_H
+#define LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KMCASMINFO_H
+
+#include "llvm/MC/MCAsmInfoELF.h"
+#include "llvm/Support/Compiler.h"
+
+namespace llvm {
+class Triple;
+
+class M88kMCAsmInfo : public MCAsmInfoELF {
+public:
+  explicit M88kMCAsmInfo(const Triple &TT);
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCCodeEmitter.cpp b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCCodeEmitter.cpp
new file mode 100644
index 000000000000..bf0ad68b4374
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCCodeEmitter.cpp
@@ -0,0 +1,108 @@
+//===-- M88kMCCodeEmitter.cpp - Convert M88k code to machine code ---------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the M88kMCCodeEmitter class.
+//
+//===----------------------------------------------------------------------===//
+
+//#include "MCTargetDesc/M88kMCFixups.h"
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/MC/MCCodeEmitter.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCFixup.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCInstrInfo.h"
+#include "llvm/MC/MCRegisterInfo.h"
+#include "llvm/MC/MCSubtargetInfo.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+#include <cassert>
+#include <cstdint>
+
+using namespace llvm;
+
+#define DEBUG_TYPE "mccodeemitter"
+
+namespace {
+
+class M88kMCCodeEmitter : public MCCodeEmitter {
+  const MCInstrInfo &MCII;
+  const MCRegisterInfo &MRI;
+  MCContext &Ctx;
+
+public:
+  M88kMCCodeEmitter(const MCInstrInfo &MCII, const MCRegisterInfo &MRI,
+                    MCContext &Ctx)
+      : MCII(MCII), MRI(MRI), Ctx(Ctx) {}
+
+  ~M88kMCCodeEmitter() override = default;
+
+  // OVerride MCCodeEmitter.
+  void encodeInstruction(const MCInst &MI, raw_ostream &OS,
+                         SmallVectorImpl<MCFixup> &Fixups,
+                         const MCSubtargetInfo &STI) const override;
+
+  // Generated by TableGen.
+  uint64_t getBinaryCodeForInstr(const MCInst &MI,
+                                 SmallVectorImpl<MCFixup> &Fixups,
+                                 const MCSubtargetInfo &STI) const;
+
+  // Functions called by the generated function.
+
+  /// \brief Return the binary encoding of operand. If the machine
+  /// operand requires relocation, record the relocation and return zero.
+  unsigned getMachineOpValue(const MCInst &MI, const MCOperand &MO,
+                             SmallVectorImpl<MCFixup> &Fixups,
+                             const MCSubtargetInfo &STI) const;
+
+  unsigned getPC26Encoding(const MCInst &MI, unsigned OpNo,
+                           SmallVectorImpl<MCFixup> &Fixups,
+                           const MCSubtargetInfo &STI) const;
+};
+
+} // end anonymous namespace
+
+void M88kMCCodeEmitter::encodeInstruction(const MCInst &MI, raw_ostream &OS,
+                                          SmallVectorImpl<MCFixup> &Fixups,
+                                          const MCSubtargetInfo &STI) const {
+  uint64_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
+  assert(MCII.get(MI.getOpcode()).getSize() == 4 && "Unexpected instr length");
+
+  // Emit bytes in big-endian
+  for (int I = (4 - 1) * 8; I >= 0; I -= 8)
+    OS << static_cast<uint8_t>((Bits >> I) & 0xff);
+}
+
+unsigned
+M88kMCCodeEmitter::getMachineOpValue(const MCInst &MI, const MCOperand &MO,
+                                     SmallVectorImpl<MCFixup> &Fixups,
+                                     const MCSubtargetInfo &STI) const {
+  if (MO.isReg())
+    return MRI.getEncodingValue(MO.getReg());
+  if (MO.isImm())
+    return static_cast<uint64_t>(MO.getImm());
+  llvm_unreachable("Unexpected operand type!");
+}
+
+unsigned M88kMCCodeEmitter::getPC26Encoding(const MCInst &MI, unsigned OpNo,
+                                            SmallVectorImpl<MCFixup> &Fixups,
+                                            const MCSubtargetInfo &STI) const {
+  // TODO Implement.
+  return 0;
+}
+
+//#define ENABLE_INSTR_PREDICATE_VERIFIER
+#include "M88kGenMCCodeEmitter.inc"
+
+MCCodeEmitter *llvm::createM88kMCCodeEmitter(const MCInstrInfo &MCII,
+                                             const MCRegisterInfo &MRI,
+                                             MCContext &Ctx) {
+  return new M88kMCCodeEmitter(MCII, MRI, Ctx);
+}
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCObjectWriter.cpp b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCObjectWriter.cpp
new file mode 100644
index 000000000000..4737059fb8d9
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCObjectWriter.cpp
@@ -0,0 +1,51 @@
+//===-- M88kMCObjectWriter.cpp - M88k ELF writer --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+//#include "MCTargetDesc/M88kMCFixups.h"
+#include "MCTargetDesc/M88kMCTargetDesc.h"
+#include "llvm/BinaryFormat/ELF.h"
+#include "llvm/MC/MCELFObjectWriter.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCFixup.h"
+#include "llvm/MC/MCObjectWriter.h"
+#include "llvm/MC/MCValue.h"
+#include "llvm/Support/ErrorHandling.h"
+#include <cassert>
+#include <cstdint>
+
+using namespace llvm;
+
+namespace {
+
+class M88kObjectWriter : public MCELFObjectTargetWriter {
+public:
+  M88kObjectWriter(uint8_t OSABI);
+  ~M88kObjectWriter() override = default;
+
+protected:
+  // Override MCELFObjectTargetWriter.
+  unsigned getRelocType(MCContext &Ctx, const MCValue &Target,
+                        const MCFixup &Fixup, bool IsPCRel) const override;
+};
+
+} // end anonymous namespace
+
+M88kObjectWriter::M88kObjectWriter(uint8_t OSABI)
+    : MCELFObjectTargetWriter(/*Is64Bit_=*/false, OSABI, ELF::EM_88K,
+                              /*HasRelocationAddend_=*/true) {}
+
+unsigned M88kObjectWriter::getRelocType(MCContext &Ctx, const MCValue &Target,
+                                        const MCFixup &Fixup,
+                                        bool IsPCRel) const {
+  return 0;
+}
+
+std::unique_ptr<MCObjectTargetWriter>
+llvm::createM88kObjectWriter(uint8_t OSABI) {
+  return std::make_unique<M88kObjectWriter>(OSABI);
+}
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCTargetDesc.cpp b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCTargetDesc.cpp
new file mode 100644
index 000000000000..61d214a26cea
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCTargetDesc.cpp
@@ -0,0 +1,87 @@
+//===-- M88kMCTargetDesc.cpp - M88k target descriptions -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "M88kMCTargetDesc.h"
+#include "M88kInstPrinter.h"
+#include "M88kMCAsmInfo.h"
+#include "TargetInfo/M88kTargetInfo.h"
+#include "llvm/MC/MCDwarf.h"
+#include "llvm/MC/MCInstrInfo.h"
+#include "llvm/MC/MCRegisterInfo.h"
+#include "llvm/MC/MCStreamer.h"
+#include "llvm/MC/MCSubtargetInfo.h"
+#include "llvm/Support/TargetRegistry.h"
+
+using namespace llvm;
+
+#define GET_INSTRINFO_MC_DESC
+#include "M88kGenInstrInfo.inc"
+
+#define GET_SUBTARGETINFO_MC_DESC
+#include "M88kGenSubtargetInfo.inc"
+
+#define GET_REGINFO_MC_DESC
+#include "M88kGenRegisterInfo.inc"
+
+static MCAsmInfo *createM88kMCAsmInfo(const MCRegisterInfo &MRI,
+                                      const Triple &TT,
+                                      const MCTargetOptions &Options) {
+  MCAsmInfo *MAI = new M88kMCAsmInfo(TT);
+  return MAI;
+}
+
+static MCInstrInfo *createM88kMCInstrInfo() {
+  MCInstrInfo *X = new MCInstrInfo();
+  InitM88kMCInstrInfo(X);
+  return X;
+}
+
+static MCRegisterInfo *createM88kMCRegisterInfo(const Triple &TT) {
+  MCRegisterInfo *X = new MCRegisterInfo();
+  InitM88kMCRegisterInfo(X, M88k::R1);
+  return X;
+}
+
+static MCSubtargetInfo *createM88kMCSubtargetInfo(const Triple &TT,
+                                                  StringRef CPU, StringRef FS) {
+  return createM88kMCSubtargetInfoImpl(TT, CPU, /*TuneCPU*/ CPU, FS);
+}
+
+static MCInstPrinter *createM88kMCInstPrinter(const Triple &T,
+                                              unsigned SyntaxVariant,
+                                              const MCAsmInfo &MAI,
+                                              const MCInstrInfo &MII,
+                                              const MCRegisterInfo &MRI) {
+  return new M88kInstPrinter(MAI, MII, MRI);
+}
+
+extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kTargetMC() {
+  // Register the MCAsmInfo.
+  TargetRegistry::RegisterMCAsmInfo(getTheM88kTarget(), createM88kMCAsmInfo);
+
+  // Register the MCCodeEmitter.
+  TargetRegistry::RegisterMCCodeEmitter(getTheM88kTarget(),
+                                        createM88kMCCodeEmitter);
+
+  // Register the MCInstrInfo.
+  TargetRegistry::RegisterMCInstrInfo(getTheM88kTarget(),
+                                      createM88kMCInstrInfo);
+  // Register the MCRegisterInfo.
+  TargetRegistry::RegisterMCRegInfo(getTheM88kTarget(),
+                                    createM88kMCRegisterInfo);
+
+  // Register the MCSubtargetInfo.
+  TargetRegistry::RegisterMCSubtargetInfo(getTheM88kTarget(),
+                                          createM88kMCSubtargetInfo);
+  // Register the MCAsmBackend.
+  TargetRegistry::RegisterMCAsmBackend(getTheM88kTarget(),
+                                       createM88kMCAsmBackend);
+  // Register the MCInstPrinter.
+  TargetRegistry::RegisterMCInstPrinter(getTheM88kTarget(),
+                                        createM88kMCInstPrinter);
+}
diff --git a/llvm/lib/Target/M88k/MCTargetDesc/M88kMCTargetDesc.h b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCTargetDesc.h
new file mode 100644
index 000000000000..980243e1c3f1
--- /dev/null
+++ b/llvm/lib/Target/M88k/MCTargetDesc/M88kMCTargetDesc.h
@@ -0,0 +1,56 @@
+//===-- M88kMCTargetDesc.h - M88k target descriptions -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KMCTARGETDESC_H
+#define LLVM_LIB_TARGET_M88K_MCTARGETDESC_M88KMCTARGETDESC_H
+
+#include "llvm/Support/DataTypes.h"
+
+#include <memory>
+
+namespace llvm {
+
+class MCAsmBackend;
+class MCCodeEmitter;
+class MCContext;
+class MCInstrInfo;
+class MCObjectTargetWriter;
+class MCRegisterInfo;
+class MCSubtargetInfo;
+class MCTargetOptions;
+class StringRef;
+class Target;
+class Triple;
+class raw_pwrite_stream;
+class raw_ostream;
+
+MCCodeEmitter *createM88kMCCodeEmitter(const MCInstrInfo &MCII,
+                                       const MCRegisterInfo &MRI,
+                                       MCContext &Ctx);
+
+MCAsmBackend *createM88kMCAsmBackend(const Target &T,
+                                     const MCSubtargetInfo &STI,
+                                     const MCRegisterInfo &MRI,
+                                     const MCTargetOptions &Options);
+
+std::unique_ptr<MCObjectTargetWriter> createM88kObjectWriter(uint8_t OSABI);
+} // end namespace llvm
+
+// Defines symbolic names for M88k registers.
+// This defines a mapping from register name to register number.
+#define GET_REGINFO_ENUM
+#include "M88kGenRegisterInfo.inc"
+
+// Defines symbolic names for the M88k instructions.
+#define GET_INSTRINFO_ENUM
+#include "M88kGenInstrInfo.inc"
+
+#define GET_SUBTARGETINFO_ENUM
+#include "M88kGenSubtargetInfo.inc"
+
+#endif
diff --git a/llvm/lib/Target/M88k/README.txt b/llvm/lib/Target/M88k/README.txt
new file mode 100644
index 000000000000..bb3adba76d6e
--- /dev/null
+++ b/llvm/lib/Target/M88k/README.txt
@@ -0,0 +1,55 @@
+M88k
+====
+
+User manuals:
+http://www.bitsavers.org/components/motorola/88000/
+
+ELF ABI:
+https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463
+
+Overview calling convention:
+https://people.cs.clemson.edu/~mark/subroutines/m88k.html
+
+gcc:
+3.3.6 is last version to support m88k
+https://gcc.gnu.org/onlinedocs/gcc-3.3.6/gcc/M88K-Options.html#M88K-Options
+
+wget ftp://ftp.nluug.nl/mirror/languages/gcc/releases/gcc-3.3.6/gcc-3.3.6.tar.gz
+
+binutils:
+2.16 is last version to support m88k
+https://sourceware.org/binutils/docs-2.16/as/M88K_002dDependent.html#M88K_002dDependent
+
+Build:
+
+wget http://ftp.gnu.org/gnu/binutils/binutils-2.16.1a.tar.bz2
+tar xjf binutils-2.16.1a.tar.bz2
+mkdir build-binutils
+cd build-binutils
+../binutils-2.16.1/configure --target=m88k-elf --prefix="$HOME/opt/cross" \
+    --disable-nls --disable-werror \
+    --disable-gdb --disable-libdecnumber --disable-readline --disable-sim
+
+../binutils-2.16.1/configure --target=m88k-unknown-openbsd --prefix="$HOME/opt/cross" \
+    --disable-nls --disable-werror \
+    --disable-gdb --disable-libdecnumber --disable-readline --disable-sim
+
+#define TARGET_BYTES_BIG_ENDIAN 1
+#define TARGET_FORMAT "elf32"
+#define TARGET_ARCH  bfd_arch_m88k
+
+git clone git://sourceware.org/git/binutils-gdb.git
+cd binutils-gdb
+git checkout binutils-2_16_1
+
+../binutils-gdb/configure --enable-targets=m88k-openbsd-elf32 --prefix="$HOME/cross" --disable-nls
+
+../binutils-gdb/configure --targets=all
+
+../binutils-gdb/configure --target=m88k-openbsd --prefix="$HOME/opt/cross" \
+    --disable-nls --disable-werror \
+    --disable-gdb --disable-libdecnumber --disable-readline --disable-sim
+
+../binutils-gdb/configure --target=m88k-openbsd --prefix="$HOME/opt/cross" \
+    --disable-nls --disable-werror \
+    --disable-gdb --disable-libdecnumber --disable-readline --disable-sim
diff --git a/llvm/lib/Target/M88k/TargetInfo/CMakeLists.txt b/llvm/lib/Target/M88k/TargetInfo/CMakeLists.txt
new file mode 100644
index 000000000000..d97eaac31142
--- /dev/null
+++ b/llvm/lib/Target/M88k/TargetInfo/CMakeLists.txt
@@ -0,0 +1,9 @@
+add_llvm_component_library(LLVMM88kInfo
+  M88kTargetInfo.cpp
+
+  LINK_COMPONENTS
+  Support
+
+  ADD_TO_COMPONENT
+  M88k
+  )
diff --git a/llvm/lib/Target/M88k/TargetInfo/M88kTargetInfo.cpp b/llvm/lib/Target/M88k/TargetInfo/M88kTargetInfo.cpp
new file mode 100644
index 000000000000..afc6e7c54330
--- /dev/null
+++ b/llvm/lib/Target/M88k/TargetInfo/M88kTargetInfo.cpp
@@ -0,0 +1,22 @@
+//===-- M88kTargetInfo.cpp - M88k target implementation -------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "TargetInfo/M88kTargetInfo.h"
+#include "llvm/Support/TargetRegistry.h"
+
+using namespace llvm;
+
+Target &llvm::getTheM88kTarget() {
+  static Target TheM88kTarget;
+  return TheM88kTarget;
+}
+
+extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kTargetInfo() {
+  RegisterTarget<Triple::m88k, /*HasJIT=*/false> X(getTheM88kTarget(), "m88k",
+                                                   "M88k", "M88k");
+}
diff --git a/llvm/lib/Target/M88k/TargetInfo/M88kTargetInfo.h b/llvm/lib/Target/M88k/TargetInfo/M88kTargetInfo.h
new file mode 100644
index 000000000000..3c97e03a122d
--- /dev/null
+++ b/llvm/lib/Target/M88k/TargetInfo/M88kTargetInfo.h
@@ -0,0 +1,20 @@
+//===-- M88kTargetInfo.h - M88k target implementation -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIB_TARGET_M88K_TARGETINFO_M88KTARGETINFO_H
+#define LLVM_LIB_TARGET_M88K_TARGETINFO_M88KTARGETINFO_H
+
+namespace llvm {
+
+class Target;
+
+Target &getTheM88kTarget();
+
+} // namespace llvm
+
+#endif // LLVM_LIB_TARGET_M88K_TARGETINFO_M88KTARGETINFO_H
diff --git a/llvm/test/CodeGen/M88k/and.ll b/llvm/test/CodeGen/M88k/and.ll
new file mode 100644
index 000000000000..7807310ee2b2
--- /dev/null
+++ b/llvm/test/CodeGen/M88k/and.ll
@@ -0,0 +1,78 @@
+; Test AND instructions.
+;
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 | FileCheck %s
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 | FileCheck %s
+
+; Check two register operands.
+define i32 @f1(i32 %a, i32 %b) {
+; CHECK-LABEL: f1:
+; CHECK: and %r2, %r2, %r3
+; CHECK: jmp %r1
+  %res = and i32 %a, %b
+  ret i32 %res
+}
+
+; Check two register operands, second operand inverted.
+define i32 @f2(i32 %a, i32 %b) {
+; CHECK-LABEL: f2:
+; CHECK: and.c %r2, %r2, %r3
+; CHECK: jmp %r1
+  %notb = xor i32 %b, -1
+  %res = and i32 %a, %notb
+  ret i32 %res
+}
+
+; Check immediate in low 16 bits, high 16 bits clear.
+define i32 @f3(i32 %a) {
+; CHECK-LABEL: f3:
+; CHECK: mask %r2, %r2, 51966
+; CHECK: jmp %r1
+  %res = and i32 %a, 51966
+  ret i32 %res
+}
+
+; Check immediate in low 16 bits, high 16 bits set.
+define i32 @func_f4(i32 %a) {
+; CHECK-LABEL: f4:
+; CHECK: and %r2, %r2, 57005
+; CHECK: jmp %r1
+  %res = and i32 %a, 4294958765 ; = 0xFFFFDEAD
+  ret i32 %res
+}
+
+; Check immediate in high 16 bits, low 16 bits clear.
+define i32 @f5(i32 %a) {
+; CHECK-LABEL: f5:
+; CHECK: mask.u %r2, %r2, 47806
+; CHECK: jmp %r1
+  %res = and i32 %a, 3133014016 ; = 0xBABE0000
+  ret i32 %res
+}
+
+; Check immediate in high 16 bits, low 16 bits set.
+define i32 @func_f6(i32 %a) {
+; CHECK-LABEL: f6:
+; CHECK: and.u %r2, %r2, 47806
+; CHECK: jmp %r1
+  %res = and i32 %a, 3133079551 ; = 0xBABEFFFF
+  ret i32 %res
+}
+
+; Check 32-bit immediate.
+define i32 @func_f7(i32 %a) {
+; CHECK-LABEL: f7:
+; CHECK: and.u %r0, %r2, 61680
+; CHECK: and %r2, %r0, 61680
+; CHECK: jmp %r1
+  %res = and i32 %a, 4042322160 ; = 0xF0F0F0F0
+  ret i32 %res
+}
+
+; Check inverted mask.
+define i32 @f8(i32 %a) {
+; CHECK-LABEL: f8:
+; CHECK: clr %r2, %r2, 16<8>
+; CHECK: jmp %r1
+  %res = and i32 %a, 4278190335 ; = 0xFF0000FF
+  ret i32 %res
+}
diff --git a/llvm/test/CodeGen/M88k/or.ll b/llvm/test/CodeGen/M88k/or.ll
new file mode 100644
index 000000000000..899ef510e40a
--- /dev/null
+++ b/llvm/test/CodeGen/M88k/or.ll
@@ -0,0 +1,60 @@
+; Test OR instructions.
+;
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 | FileCheck %s
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 | FileCheck %s
+
+; Check two register operands.
+define i32 @f1(i32 %a, i32 %b) {
+; CHECK-LABEL: f1:
+; CHECK: or %r2, %r2, %r3
+; CHECK: jmp %r1
+  %res = or i32 %a, %b
+  ret i32 %res
+}
+
+; Check two register operands, second operand inverted.
+define i32 @f2(i32 %a, i32 %b) {
+; CHECK-LABEL: f2:
+; CHECK: or.c %r2, %r2, %r3
+; CHECK: jmp %r1
+  %notb = xor i32 %b, -1
+  %res = or i32 %a, %notb
+  ret i32 %res
+}
+
+; Check immediate in low 16 bits, high 16 bits clear.
+define i32 @f3(i32 %a) {
+; CHECK-LABEL: f3:
+; CHECK: or %r2, %r2, 160
+; CHECK: jmp %r1
+  %res = or i32 %a, 160 ; = 0xA0
+  ret i32 %res
+}
+
+; Check immediate in high 16 bits, low 16 bits set.
+define i32 @func_f4(i32 %a) {
+; CHECK-LABEL: f4:
+; CHECK: or.u %r2, %r2, 47806
+; CHECK: jmp %r1
+  %res = or i32 %a, 3133014016 ; = 0xBABE0000
+  ret i32 %res
+}
+
+; Check 32-bit immediate.
+define i32 @func_f5(i32 %a) {
+; CHECK-LABEL: f5:
+; CHECK: or.u %r0, %r2, 61680
+; CHECK: or %r2, %r0, 61680
+; CHECK: jmp %r1
+  %res = or i32 %a, 4042322160 ; = 0xF0F0F0F0
+  ret i32 %res
+}
+
+; Check mask.
+define i32 @f6(i32 %a) {
+; CHECK-LABEL: f6:
+; CHECK: set %r2, %r2, 16<8>
+; CHECK: jmp %r1
+  %res = or i32 %a, 16776960 ; 0x00FFFF00
+  ret i32 %res
+}
diff --git a/llvm/test/CodeGen/M88k/shift.ll b/llvm/test/CodeGen/M88k/shift.ll
new file mode 100644
index 000000000000..eedbe4109a21
--- /dev/null
+++ b/llvm/test/CodeGen/M88k/shift.ll
@@ -0,0 +1,70 @@
+; Test shift instructions.
+;
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 | FileCheck %s
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 | FileCheck %s
+
+; Check two register operands.
+define i32 @f1(i32 %a, i32 %b) {
+; CHECK-LABEL: f1:
+; CHECK: mak %r2, %r2, %r3
+; CHECK: jmp %r1
+  %res = shl i32 %a, %b
+  ret i32 %res
+}
+
+; Check two register operands.
+define i32 @f2(i32 %a, i32 %b) {
+; CHECK-LABEL: f2:
+; CHECK: extu %r2, %r2, %r3
+; CHECK: jmp %r1
+  %res = lshr i32 %a, %b
+  ret i32 %res
+}
+
+; Check two register operands.
+define i32 @f3(i32 %a, i32 %b) {
+; CHECK-LABEL: f3:
+; CHECK: ext %r2, %r2, %r3
+; CHECK: jmp %r1
+  %res = ashr i32 %a, %b
+  ret i32 %res
+}
+
+; Check immediate operand.
+define i32 @f4(i32 %a) {
+; CHECK-LABEL: f4:
+; CHECK: mak %r2, %r2, 0<2>
+; CHECK: jmp %r1
+  %res = shl i32 %a, 2
+  ret i32 %res
+}
+
+; Check combine shift and and.
+define i32 @f5(i32 %a) {
+; CHECK-LABEL: f5:
+; CHECK: extu %r2, %r2, 5<1>
+; CHECK: jmp %r1
+  %shift = lshr i32 %a, 1
+  %res = and i32 %shift, 31
+  ret i32 %res
+}
+
+; Check combine shift and and.
+define i32 @f6(i32 %a) {
+; CHECK-LABEL: f6:
+; CHECK: extu %r2, %r2, 5<1>
+; CHECK: jmp %r1
+  %shift = ashr i32 %a, 1
+  %res = and i32 %shift, 31
+  ret i32 %res
+}
+
+; Check combine shift and and.
+define i32 @f7(i32 %a) {
+; CHECK-LABEL: f7:
+; CHECK: mak %r2, %r2, 8<15>
+; CHECK: jmp %r1
+  %and = and i32 %a, 255 
+  %res = shl i32 %and, 15
+  ret i32 %res
+}
\ No newline at end of file
diff --git a/llvm/test/CodeGen/M88k/xor.ll b/llvm/test/CodeGen/M88k/xor.ll
new file mode 100644
index 000000000000..94cfee081965
--- /dev/null
+++ b/llvm/test/CodeGen/M88k/xor.ll
@@ -0,0 +1,51 @@
+; Test XOR instructions.
+;
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88100 | FileCheck %s
+; RUN: llc < %s -mtriple=m88k-openbsd -mcpu=mc88110 | FileCheck %s
+
+; Check two register operands.
+define i32 @f1(i32 %a, i32 %b) {
+; CHECK-LABEL: f1:
+; CHECK: xor %r2, %r2, %r3
+; CHECK: jmp %r1
+  %res = xor i32 %a, %b
+  ret i32 %res
+}
+
+; Check two register operands, second operand inverted.
+define i32 @f2(i32 %a, i32 %b) {
+; CHECK-LABEL: f2:
+; CHECK: xor.c %r2, %r3, %r2
+; CHECK: jmp %r1
+  %notb = xor i32 %b, -1
+  %res = xor i32 %a, %notb
+  ret i32 %res
+}
+
+; Check immediate in low 16 bits, high 16 bits clear.
+define i32 @f3(i32 %a) {
+; CHECK-LABEL: f3:
+; CHECK: xor %r2, %r2, 255
+; CHECK: jmp %r1
+  %res = xor i32 %a, 255
+  ret i32 %res
+}
+
+; Check immediate in high 16 bits, low 16 bits set.
+define i32 @func_f4(i32 %a) {
+; CHECK-LABEL: f4:
+; CHECK: xor.u %r2, %r2, 47806
+; CHECK: jmp %r1
+  %res = xor i32 %a, 3133014016 ; = 0xBABE0000
+  ret i32 %res
+}
+
+; Check 32-bit immediate.
+define i32 @func_f5(i32 %a) {
+; CHECK-LABEL: f5:
+; CHECK: xor.u %r0, %r2, 61680
+; CHECK: xor %r2, %r0, 61680
+; CHECK: jmp %r1
+  %res = xor i32 %a, 4042322160 ; = 0xF0F0F0F0
+  ret i32 %res
+}
diff --git a/llvm/test/MC/M88k/valid.s b/llvm/test/MC/M88k/valid.s
new file mode 100644
index 000000000000..f0e66c414e8e
--- /dev/null
+++ b/llvm/test/MC/M88k/valid.s
@@ -0,0 +1,263 @@
+# RUN: llvm-mc  %s -triple=m88k-unknown-openbsd -show-encoding -mcpu=mc88100 | FileCheck %s
+
+# CHECK: addu     %r0, %r1, %r2          # encoding: [0xf4,0x01,0x60,0x02]
+# CHECK: addu.ci  %r1, %r2, %r3          # encoding: [0xf4,0x22,0x62,0x03]
+# CHECK: addu.co  %r2, %r3, %r4          # encoding: [0xf4,0x43,0x61,0x04]
+# CHECK: addu.cio %r3, %r4, %r5          # encoding: [0xf4,0x64,0x63,0x05]
+# CHECK: addu     %r4, %r5, 0            # encoding: [0x60,0x85,0x00,0x00]
+# CHECK: addu     %r4, %r5, 4096         # encoding: [0x60,0x85,0x10,0x00]
+
+# CHECK: and      %r0, %r1, %r2          # encoding: [0xf4,0x01,0x40,0x02]
+# CHECK: and.c    %r1, %r2, %r3          # encoding: [0xf4,0x22,0x44,0x03]
+# CHECK: and      %r2, %r3, 0            # encoding: [0x40,0x43,0x00,0x00]
+# CHECK: and      %r2, %r3, 4096         # encoding: [0x40,0x43,0x10,0x00]
+# CHECK: and.u    %r2, %r3, 0            # encoding: [0x44,0x43,0x00,0x00]
+# CHECK: and.u    %r2, %r3, 4096         # encoding: [0x44,0x43,0x10,0x00]
+
+# CHECK: clr      %r1, %r2, 5<15>        # encoding: [0xf0,0x22,0x80,0xaf]
+# CHECK: clr      %r1, %r2, %r3          # encoding: [0xf4,0x22,0x80,0x03]
+# CHECK: clr      %r1, %r2, 0<6>         # encoding: [0xf0,0x22,0x80,0x06]
+# CHECK: clr      %r1, %r2, 0<6>         # encoding: [0xf0,0x22,0x80,0x06]
+# CHECK: cmp      %r0, %r1, %r2          # encoding: [0xf4,0x01,0x7c,0x02]
+# COM: CHECK: cmp      %r0, %r2, 0            # encoding: [0x7c,0x02,0x00,0x00]
+# COM: CHECK: cmp      %r0, %r2, 4096         # encoding: [0x7c,0x02,0x10,0x00]
+
+# CHECK: ext      %r0, %r1, 10<5>        # encoding: [0xf0,0x01,0x91,0x45]
+# CHECK: ext      %r1, %r2, %r3          # encoding: [0xf4,0x22,0x90,0x03]
+# CHECK: ext      %r2, %r3, 0<6>         # encoding: [0xf0,0x43,0x90,0x06]
+# CHECK: ext      %r2, %r3, 0<6>         # encoding: [0xf0,0x43,0x90,0x06]
+
+# CHECK: extu     %r0, %r1, 10<5>        # encoding: [0xf0,0x01,0x99,0x45]
+# CHECK: extu     %r1, %r2, %r3          # encoding: [0xf4,0x22,0x98,0x03]
+# CHECK: extu     %r1, %r2, 0<6>         # encoding: [0xf0,0x22,0x98,0x06]
+# CHECK: extu     %r1, %r2, 0<6>         # encoding: [0xf0,0x22,0x98,0x06]
+
+# CHECK: ff0      %r1, %r7               # encoding: [0xf4,0x20,0xec,0x07]
+# CHECK: ff1      %r3, %r8               # encoding: [0xf4,0x60,0xe8,0x08]
+
+# CHECK: jmp      %r0                    # encoding: [0xf4,0x00,0xc0,0x00]
+# CHECK: jmp.n    %r10                   # encoding: [0xf4,0x00,0xc4,0x0a]
+# CHECK: jsr      %r10                   # encoding: [0xf4,0x00,0xc8,0x0a]
+# CHECK: jsr.n    %r13                   # encoding: [0xf4,0x00,0xcc,0x0d]
+
+# CHECK: ld.b     %r0, %r1, 0            # encoding: [0x1c,0x01,0x00,0x00]
+# CHECK: ld.b     %r0, %r1, 4096         # encoding: [0x1c,0x01,0x10,0x00]
+# CHECK: ld.bu    %r0, %r1, 0            # encoding: [0x0c,0x01,0x00,0x00]
+# CHECK: ld.bu    %r0, %r1, 4096         # encoding: [0x0c,0x01,0x10,0x00]
+# CHECK: ld.h     %r0, %r1, 0            # encoding: [0x18,0x01,0x00,0x00]
+# CHECK: ld.h     %r0, %r1, 4096         # encoding: [0x18,0x01,0x10,0x00]
+# CHECK: ld.hu    %r0, %r1, 0            # encoding: [0x08,0x01,0x00,0x00]
+# CHECK: ld.hu    %r0, %r1, 4096         # encoding: [0x08,0x01,0x10,0x00]
+# CHECK: ld       %r0, %r1, 0            # encoding: [0x14,0x01,0x00,0x00]
+# CHECK: ld       %r0, %r1, 4096         # encoding: [0x14,0x01,0x10,0x00]
+# CHECK: ld.d     %r0, %r1, 0            # encoding: [0x10,0x01,0x00,0x00]
+# CHECK: ld.d     %r0, %r1, 4096         # encoding: [0x10,0x01,0x10,0x00]
+
+# CHECK: mak      %r0, %r1, 10<5>        # encoding: [0xf0,0x01,0xa1,0x45]
+# CHECK: mak      %r0, %r1, %r2          # encoding: [0xf4,0x01,0xa0,0x02]
+# CHECK: mak      %r0, %r1, 0<6>         # encoding: [0xf0,0x01,0xa0,0x06]
+# CHECK: mak      %r0, %r1, 0<6>         # encoding: [0xf0,0x01,0xa0,0x06]
+# CHECK: mask     %r0, %r1, 0            # encoding: [0x48,0x01,0x00,0x00]
+# CHECK: mask     %r0, %r1, 4096         # encoding: [0x48,0x01,0x10,0x00]
+# CHECK: mask.u   %r0, %r1, 0            # encoding: [0x4c,0x01,0x00,0x00]
+# CHECK: mask.u   %r0, %r1, 4096         # encoding: [0x4c,0x01,0x10,0x00]
+
+# CHECK: or       %r0, %r1, %r2          # encoding: [0xf4,0x01,0x58,0x02]
+# CHECK: or.c     %r1, %r7, %r10         # encoding: [0xf4,0x27,0x5c,0x0a]
+# CHECK: or       %r0, %r4, 0            # encoding: [0x58,0x04,0x00,0x00]
+# CHECK: or       %r0, %r4, 4096         # encoding: [0x58,0x04,0x10,0x00]
+# CHECK: or.u     %r0, %r1, 0            # encoding: [0x5c,0x01,0x00,0x00]
+# CHECK: or.u     %r2, %r4, 4096         # encoding: [0x5c,0x44,0x10,0x00]
+
+# CHECK: rot      %r0, %r1, <5>          # encoding: [0xf0,0x01,0xa8,0x05]
+# CHECK: rot      %r2, %r4, %r6          # encoding: [0xf4,0x44,0xa8,0x06]
+
+# CHECK: set      %r0, %r1, 10<5>        # encoding: [0xf0,0x01,0x89,0x45]
+# CHECK: set      %r2, %r4, %r6          # encoding: [0xf4,0x44,0x88,0x06]
+# CHECK: set      %r3, %r7, 0<6>         # encoding: [0xf0,0x67,0x88,0x06]
+# CHECK: set      %r3, %r7, 0<6>         # encoding: [0xf0,0x67,0x88,0x06]
+# CHECK: st.b     %r0, %r1, 0            # encoding: [0x2c,0x01,0x00,0x00]
+# CHECK: st.b     %r0, %r1, 4096         # encoding: [0x2c,0x01,0x10,0x00]
+# CHECK: st.h     %r0, %r1, 0            # encoding: [0x28,0x01,0x00,0x00]
+# CHECK: st.h     %r0, %r1, 4096         # encoding: [0x28,0x01,0x10,0x00]
+# CHECK: st       %r0, %r1, 0            # encoding: [0x24,0x01,0x00,0x00]
+# CHECK: st       %r0, %r1, 4096         # encoding: [0x24,0x01,0x10,0x00]
+# CHECK: st.d     %r0, %r1, 0            # encoding: [0x20,0x01,0x00,0x00]
+# CHECK: st.d     %r0, %r1, 4096         # encoding: [0x20,0x01,0x10,0x00]
+# COM: CHECK: st.b     %r0, %r1, %r2          # encoding: [0xf4,0x01,0x2c,0x02]
+# COM: CHECK: st.h     %r2, %r3, %r4          # encoding: [0xf4,0x43,0x28,0x04]
+# COM: CHECK: st       %r4, %r5, %r6          # encoding: [0xf4,0x85,0x24,0x06]
+# COM: CHECK: st.d     %r5, %r6, %r7          # encoding: [0xf4,0xa6,0x20,0x07]
+# COM: CHECK: st.b.usr %r6, %r7, %r8          # encoding: [0xf4,0xc7,0x2d,0x08]
+# COM: CHECK: st.h.usr %r8, %r9, %r1          # encoding: [0xf5,0x09,0x29,0x01]
+# COM: CHECK: st.usr   %r1, %r2, %r3          # encoding: [0xf4,0x22,0x25,0x03]
+# COM: CHECK: st.d.usr %r2, %r3, %r4          # encoding: [0xf4,0x43,0x21,0x04]
+# COM: CHECK: st.b     %r0, %r1[%r2]          # encoding: [0xf4,0x01,0x2e,0x02]
+# COM: CHECK: st.h     %r2, %r3[%r4]          # encoding: [0xf4,0x43,0x2a,0x04]
+# COM: CHECK: st       %r4, %r5[%r6]          # encoding: [0xf4,0x85,0x26,0x06]
+# COM: CHECK: st.d     %r5, %r6[%r7]          # encoding: [0xf4,0xa6,0x22,0x07]
+# COM: CHECK: st.b.usr %r6, %r7[%r8]          # encoding: [0xf4,0xc7,0x2f,0x08]
+# COM: CHECK: st.h.usr %r8, %r9[%r1]          # encoding: [0xf5,0x09,0x2b,0x01]
+# COM: CHECK: st.usr   %r1, %r2[%r3]          # encoding: [0xf4,0x22,0x27,0x03]
+# COM: CHECK: st.d.usr %r2, %r3[%r4]          # encoding: [0xf4,0x43,0x23,0x04]
+# COM: CHECK: stcr     %r0, %cr10             # encoding: [0x80,0x00,0x81,0x40]
+
+# CHECK: subu     %r0, %r1, %r2          # encoding: [0xf4,0x01,0x64,0x02]
+# CHECK: subu.ci  %r1, %r2, %r3          # encoding: [0xf4,0x22,0x66,0x03]
+# CHECK: subu.co  %r3, %r4, %r5          # encoding: [0xf4,0x64,0x65,0x05]
+# CHECK: subu.cio %r4, %r5, %r6          # encoding: [0xf4,0x85,0x67,0x06]
+# CHECK: subu     %r5, %r6, 0            # encoding: [0x64,0xa6,0x00,0x00]
+# CHECK: subu     %r5, %r6, 4096         # encoding: [0x64,0xa6,0x10,0x00]
+
+# CHECK: xor      %r0, %r1, %r2          # encoding: [0xf4,0x01,0x50,0x02]
+# CHECK: xor.c    %r1, %r2, %r3          # encoding: [0xf4,0x22,0x54,0x03]
+# CHECK: xor      %r2, %r3, 0            # encoding: [0x50,0x43,0x00,0x00]
+# CHECK: xor      %r2, %r4, 4096         # encoding: [0x50,0x44,0x10,0x00]
+# CHECK: xor.u    %r1, %r2, 0            # encoding: [0x54,0x22,0x00,0x00]
+# CHECK: xor.u    %r2, %r3, 4096         # encoding: [0x54,0x43,0x10,0x00]
+
+foo:
+  # unsigned integer add
+  addu     %r0, %r1, %r2
+  addu.ci  %r1, %r2, %r3
+  addu.co  %r2, %r3, %r4
+  addu.cio %r3, %r4, %r5
+  addu     %r4, %r5, 0
+  addu     %r4, %r5, 4096
+
+  # logical and
+  and      %r0, %r1, %r2
+  and.c    %r1, %r2, %r3
+  and      %r2, %r3, 0
+  and      %r2, %r3, 4096
+  and.u    %r2, %r3, 0
+  and.u    %r2, %r3, 4096
+
+  # uncoditional branch
+  br       0
+
+  # clear bit field
+  clr      %r1, %r2, 5<15>
+  clr      %r1, %r2, %r3
+  clr      %r1, %r2, 6
+  clr      %r1, %r2, <6>
+
+  # integer compare
+  cmp      %r0, %r1, %r2
+#  cmp      %r0, %r2, 0
+#  cmp      %r0, %r2, 4096
+
+  # extract signed bit field
+  ext      %r0, %r1, 10<5>
+  ext      %r1, %r2, %r3
+  ext      %r2, %r3, 6
+  ext      %r2, %r3, <6>
+
+  # extract unsigned bit field
+  extu     %r0, %r1, 10<5>
+  extu     %r1, %r2, %r3
+  extu     %r1, %r2, 6
+  extu     %r1, %r2, <6>
+
+  # find first bit clear
+  ff0      %r1, %r7
+
+  # find first bit set
+  ff1      %r3, %r8
+
+  # unconditional jump
+  jmp      %r0
+  jmp.n    %r10
+
+  # jump to subroutine
+  jsr      %r10
+  jsr.n    %r13
+
+  # load register from memory
+  ld.b     %r0, %r1, 0
+  ld.b     %r0, %r1, 4096
+  ld.bu    %r0, %r1, 0
+  ld.bu    %r0, %r1, 4096
+  ld.h     %r0, %r1, 0
+  ld.h     %r0, %r1, 4096
+  ld.hu    %r0, %r1, 0
+  ld.hu    %r0, %r1, 4096
+  ld       %r0, %r1, 0
+  ld       %r0, %r1, 4096
+  ld.d     %r0, %r1, 0
+  ld.d     %r0, %r1, 4096
+
+  # make bit field
+  mak      %r0, %r1, 10<5>
+  mak      %r0, %r1, %r2
+  mak      %r0, %r1, 6
+  mak      %r0, %r1, <6>
+
+  # logical mask immediate
+  mask     %r0, %r1, 0
+  mask     %r0, %r1, 4096
+  mask.u   %r0, %r1, 0
+  mask.u   %r0, %r1, 4096
+
+  # logical or
+  or       %r0, %r1, %r2
+  or.c     %r1, %r7, %r10
+  or       %r0, %r4, 0
+  or       %r0, %r4, 4096
+  or.u     %r0, %r1, 0
+  or.u     %r2, %r4, 4096
+
+  # rotate register
+  rot      %r0, %r1, <5>
+  rot      %r2, %r4, %r6
+
+  # set bit field
+  set      %r0, %r1, 10<5>
+  set      %r2, %r4, %r6
+  set      %r3, %r7, 6
+  set      %r3, %r7, <6>
+
+  # store register to memory
+  st.b     %r0, %r1, 0
+  st.b     %r0, %r1, 4096
+  st.h     %r0, %r1, 0
+  st.h     %r0, %r1, 4096
+  st       %r0, %r1, 0
+  st       %r0, %r1, 4096
+  st.d     %r0, %r1, 0
+  st.d     %r0, %r1, 4096
+#  st.b     %r0, %r1, %r2
+#  st.h     %r2, %r3, %r4
+#  st       %r4, %r5, %r6
+#  st.d     %r5, %r6, %r7
+#  st.b.usr %r6, %r7, %r8
+#  st.h.usr %r8, %r9, %r1
+#  st.usr   %r1, %r2, %r3
+#  st.d.usr %r2, %r3, %r4
+#  st.b     %r0, %r1[%r2]
+#  st.h     %r2, %r3[%r4]
+#  st       %r4, %r5[%r6]
+#  st.d     %r5, %r6[%r7]
+#  st.b.usr %r6, %r7[%r8]
+#  st.h.usr %r8, %r9[%r1]
+#  st.usr   %r1, %r2[%r3]
+#  st.d.usr %r2, %r3[%r4]
+
+  # store to control register
+#  stcr %r0, %cr10
+
+  # unsigned integer subtract
+  subu     %r0, %r1, %r2
+  subu.ci  %r1, %r2, %r3
+  subu.co  %r3, %r4, %r5
+  subu.cio %r4, %r5, %r6
+  subu     %r5, %r6, 0
+  subu     %r5, %r6, 4096
+
+  # logical exclusive or
+  xor      %r0, %r1, %r2
+  xor.c    %r1, %r2, %r3
+  xor      %r2, %r3, 0
+  xor      %r2, %r4, 4096
+  xor.u    %r1, %r2, 0
+  xor.u    %r2, %r3, 4096
